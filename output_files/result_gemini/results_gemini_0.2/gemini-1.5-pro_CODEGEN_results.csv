gt_code,level,refactor_code,rationale
"var createHelloWorld = function() { 
    return function() {
        return ""Hello World"";
    }
}",Easy,"/**
 * @return {Function}
 */
var createHelloWorld = function() {
    return function(...args) {
        return ""Hello World"";
    }
};

/**
 * const f = createHelloWorld();
 * f(); // ""Hello World""
 */","The `createHelloWorld` function returns a new function. This inner function uses the spread syntax (`...args`) to accept any number of arguments, although it ignores them. It always returns the string ""Hello World"". This solution satisfies all the prompt requirements."
"var createCounter = function(init) {
  let presentCount = init;

  function increment() {
    return ++presentCount;
  }

  function decrement() {
      return --presentCount;
  }

  function reset() {
      return (presentCount = init);
  }

  return { increment, decrement, reset };
};",Easy,"/**
 * @param {integer} init
 * @return { increment: Function, decrement: Function, reset: Function }
 */
var createCounter = function(init) {
    let currentCount = init;

    const increment = () => {
        currentCount += 1;
        return currentCount;
    };

    const decrement = () => {
        currentCount -= 1;
        return currentCount;
    };

    const reset = () => {
        currentCount = init;
        return currentCount;
    };

    return { increment, decrement, reset };
};","This code directly implements the requested functionality. It initializes currentCount with the provided init value. The increment, decrement, and reset functions modify and return the currentCount as specified. The object containing these functions is then returned."
"var map = function(arr, fn) {
    const transformedArr = [];
    arr.forEach((element, index) => {
      transformedArr[index] = fn(element, index);
    });
    return transformedArr;
  };",Easy,"/**
 * @param {number[]} arr
 * @param {Function} fn
 * @return {number[]}
 */
var map = function(arr, fn) {
    const newArray = [];
    for (let i = 0; i < arr.length; i++) {
        newArray.push(fn(arr[i], i));
    }
    return newArray;
};","This code iterates through the input array `arr` using a `for` loop. In each iteration, it applies the provided function `fn` to the current element `arr[i]` and its index `i`. The result of `fn(arr[i], i)` is then pushed into the `newArray`. Finally, the function returns the `newArray` containing the transformed elements."
"var filter = function(arr, fn) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i)) {
      result.push(arr[i]);
    }
  }
  return result;
};",Easy,"/**
 * @param {number[]} arr
 * @param {Function} fn
 * @return {number[]}
 */
var filter = function(arr, fn) {
    const filteredArr = [];
    for (let i = 0; i < arr.length; i++) {
        if (fn(arr[i], i)) {
            filteredArr.push(arr[i]);
        }
    }
    return filteredArr;
};","This code iterates through the input array `arr`. In each iteration, it calls the provided function `fn` with the current element `arr[i]` and its index `i`. If `fn` returns a truthy value, the element is added to the `filteredArr`. Finally, the function returns the `filteredArr` containing only the elements that satisfied the filter function. Error handling isn't explicitly needed here since the function is designed to handle various data types and scenarios due to the flexible nature of the filter function parameter."
"/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function(nums, fn, init) {
  let val = init;
  for (let i = 0; i < nums.length; i++) {
    val = fn(val, nums[i]);
  }
  return val;
};",Easy,"/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function(nums, fn, init) {
    let val = init;
    if (nums.length === 0) {
        return init;
    }
    for (let i = 0; i < nums.length; i++) {
        val = fn(val, nums[i]);
    }
    return val;
};","This code iterates through the input array `nums`. In each iteration, it applies the provided function `fn` with the current accumulated value `val` and the current element of the array `nums[i]`. The result of this function call updates the accumulated value `val`. If the input array is empty, the initial value `init` is returned directly. This logic effectively replicates the functionality of the `reduce` method without using it directly."
"/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var timeLimit = function(fn, t) {
  return async function(...args) {
    return new Promise((delayresolve, reject) => {
      const timeoutId = setTimeout(() => {
        clearTimeout(timeoutId);
        reject(""Time Limit Exceeded"");
      }, t);

      fn(...args)
        .then((result) => {
          clearTimeout(timeoutId);
          delayresolve(result);
        })
        .catch((error) => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  };
};

/**
 * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);
 * limited(150).catch(console.log) // ""Time Limit Exceeded"" at t=100ms
 */",Medium,"/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function} 
 */
var timeLimit = function(fn, t) {
    return async function(...args) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(""Time Limit Exceeded"");
            }, t);

            try {
                const result = await fn(...args);
                clearTimeout(timeoutId);
                resolve(result);
            } catch (error) {
                clearTimeout(timeoutId);
                reject(error);
            }
        });
    };
};","The solution uses a Promise and a setTimeout to implement the time limit functionality. The Promise is resolved with the result of the input function if it completes within the time limit. If the time limit is exceeded, the Promise is rejected with the message 'Time Limit Exceeded'. A try-catch block handles potential errors during the execution of the input function. The setTimeout is cleared in both the resolve and reject cases to prevent memory leaks and unexpected behavior.  The ...args syntax is used to pass any number of arguments to the input function."
"const TimeLimitedCache = function() {
    this.cache = new Map();  // Using Map so we don't need a size variable
};

TimeLimitedCache.prototype.set = function(key, value, duration) {
    let found = this.cache.has(key);
    if (found) clearTimeout(this.cache.get(key).ref);  // Cancel previous timeout
    this.cache.set(key, {
        value,  // Equivalent to `value: value`
        ref: setTimeout(() => this.cache.delete(key), duration)
    });
    return found;
};

TimeLimitedCache.prototype.get = function(key) {
    return this.cache.has(key) ? this.cache.get(key).value : -1;
};

TimeLimitedCache.prototype.count = function() {
    return this.cache.size;
};",Medium,"var TimeLimitedCache = function() {
    this.cache = new Map();
    this.timeouts = new Map();
};

/** 
 * @param {number} key
 * @param {number} value
 * @param {number} duration time until expiration in ms
 * @return {boolean} if un-expired key already existed
 */
TimeLimitedCache.prototype.set = function(key, value, duration) {
    const existingTimeout = this.timeouts.get(key);
    if (existingTimeout) {
        clearTimeout(existingTimeout);
    }

    const existed = this.cache.has(key);
    this.cache.set(key, value);

    const timeout = setTimeout(() => {
        this.cache.delete(key);
        this.timeouts.delete(key);
    }, duration);
    this.timeouts.set(key, timeout);

    return existed;
};

/** 
 * @param {number} key
 * @return {number} value associated with key
 */
TimeLimitedCache.prototype.get = function(key) {
    if (this.cache.has(key)) {
        return this.cache.get(key);
    }
    return -1;
};

/** 
 * @return {number} count of non-expired keys
 */
TimeLimitedCache.prototype.count = function() {
    return this.cache.size;
};","This code uses a Map to store the key-value pairs and another Map to store the timeouts associated with each key. The set method checks if a timeout already exists for the given key. If so, it clears the existing timeout. It then sets the key-value pair in the cache and creates a new timeout. The get method returns the value associated with the key if it exists and hasn't expired. The count method returns the number of non-expired keys in the cache. Using Maps allows for efficient key lookups and deletions."
"var debounce = function(fn, t) {
    let id;
        return function (...args) {
                clearTimeout(id);
                id = setTimeout(() => fn(...args), t);
        }
};",Medium,"/**
 * @param {Function} fn
 * @param {number} t milliseconds
 * @return {Function} 
 */
var debounce = function(fn, t) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fn(...args);
        }, t);
    }
};","This code implements debounce functionality by using setTimeout to schedule the execution of the given function fn after t milliseconds. Each subsequent call to the debounced function within the t millisecond window clears the existing timeout using clearTimeout and sets a new timeout, effectively delaying the execution until t milliseconds have passed since the last call. The ...args syntax allows the debounced function to accept and pass any arguments to the original function fn when it's eventually executed. By storing timeoutId in the closure, we ensure that each call to the debounced function has access to and can clear the appropriate timeout."
"var promiseAll = async function(functions) {
    return new Promise((resolve, reject) => {
        let results = [];
        functions.forEach(fn => {
            fn()
            .then(val => results.push(val))
            .catch(reason => reject(reason));
        });
        resolve(results);
    })};

var promiseAll = async function(functions) {
    return new Promise((resolve,reject)=>{
        if(functions.length === 0) {
            resolve([]);
            return;
        }
        const arr=new Array(functions.length);
        arr.fill(null);
        let count=0
        functions.forEach(async(fn,i)=>{
            try{
                arr[i]=await fn()
                count++
            
                if(count===functions.length){
                    resolve(arr);
                }
            }
            catch(e){
                reject(e);
            }
        
        });
    });
};",Medium,"/**
 * @param {Array<Function>} functions
 * @return {Promise<any>}
 */
var promiseAll = function(functions) {
  return new Promise((resolve, reject) => {
    const results = [];
    let completedCount = 0;
    const n = functions.length;

    if (n === 0) {
      resolve([]);
      return;
    }

    for (let i = 0; i < n; i++) {
      functions[i]()
        .then(result => {
          results[i] = result;
          completedCount++;
          if (completedCount === n) {
            resolve(results);
          }
        })
        .catch(error => {
          reject(error);
        });
    }
  });
};","This code implements a custom promiseAll function that mimics the behavior of Promise.all. It initializes an array results to store the resolved values and a counter completedCount. The function iterates through the input functions array. For each function, it calls the function and attaches a then handler and a catch handler to the returned promise. The then handler stores the resolved value in the results array at the corresponding index and increments completedCount. If completedCount equals the length of functions, it resolves the main promise with results. The catch handler rejects the main promise with the reason of the first rejection. If the input array is empty, it resolves the promise with an empty array."
"class EventEmitter {
  constructor() {
    this.events = new Map();
  }

  subscribe(event, cb) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    const listeners = this.events.get(event);
    listeners.push(cb);

    return {
      unsubscribe: () => {
        const index = listeners.indexOf(cb);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }

  emit(event, args = []) {
    if (!this.events.has(event)) {
      return [];
    }

    const listeners = this.events.get(event);
    const results = [];

    for (const listener of listeners) {
      results.push(listener(...args));
    }

    return results;
  }
}",Medium,"class EventEmitter {
    constructor() {
        this.events = {};
    }

    /**
     * @param {string} eventName
     * @param {Function} callback
     * @return {Object}
     */
    subscribe(eventName, callback) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }
        this.events[eventName].push(callback);

        return {
            unsubscribe: () => {
                if (this.events[eventName]) {
                    this.events[eventName] = this.events[eventName].filter(
                        (cb) => cb !== callback
                    );
                }
            },
        };
    }

    /**
     * @param {string} eventName
     * @param {Array} args
     * @return {Array}
     */
    emit(eventName, args = []) {
        const callbacks = this.events[eventName] || [];
        return callbacks.map((callback) => callback(...args));
    }
}","This code implements the EventEmitter class with subscribe and emit methods.  The subscribe method adds the callback to an array associated with the event name. It returns an object with an unsubscribe method that removes the callback. The emit method iterates through the callbacks for the given event and calls each one with the provided arguments, returning the results in an array.  Error handling is implicit - if an event has no subscribers, an empty array is returned. This approach is efficient and adheres to the prompt's requirements."
"class Calculator {
  constructor(value) {
    this.result = value;
  }
  add(value) {
    this.result += value;
    return this;
  }

  subtract(value) {
    this.result -= value;
    return this;
  }

  multiply(value) {
    this.result *= value;
    return this;
  }

  divide(value) {
    if (value === 0) {
      throw new Error('Division by zero is not allowed');
    }
    this.result /= value;
    return this;
  }

  power(value) {
    this.result = Math.pow(this.result, value);
    return this;
  }

  getResult() {
    return this.result;
  }
}",Medium,"class Calculator {
    /** 
     * @param {number} value
     */
    constructor(value) {
        this.result = value;
    }

    /** 
     * @param {number} value
     * @return {Calculator}
     */
    add(value) {
        this.result += value;
        return this;
    }

    /** 
     * @param {number} value
     * @return {Calculator}
     */
    subtract(value) {
        this.result -= value;
        return this;
    }

    /** 
     * @param {number} value
     * @return {Calculator}
     */
    multiply(value) {
        this.result *= value;
        return this;
    }

    /** 
     * @param {number} value
     * @return {Calculator}
     */
    divide(value) {
        if (value === 0) {
            throw new Error(""Division by zero is not allowed"");
        }
        this.result /= value;
        return this;
    }

    /** 
     * @param {number} value
     * @return {Calculator}
     */
    power(value) {
        this.result = Math.pow(this.result, value);
        return this;
    }

    /** 
     * @return {number}
     */
    getResult() {
        return this.result;
    }
}","The Calculator class is designed to perform basic arithmetic operations with method chaining. The constructor initializes the result with the provided value. Each arithmetic method updates the result and returns the Calculator instance, enabling chaining. Error handling is implemented for division by zero. The getResult method returns the final calculated result. This approach ensures clear separation of concerns and maintainability."
"/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */

class ListNode {
  constructor(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
  }
}

function arrayToList(array) {
    if (array.length === 0) return null;

    let head = new ListNode(array[0]);
    let current = head;

    for (let i = 1; i < array.length; i++) {
        current.next = new ListNode(array[i]);
        current = current.next;
    }

    return head;
}

var mergeKLists = function (lists) {
    let nums = []

    for (let i = 0; i < lists.length; i++) {
        let current = lists[i]
        while (current !== null) {
            nums.push(current.val)
            current = current.next
        }
    }

    return arrayToList(nums.sort((a, b) => a - b))
};",Medium,"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    if (!lists || lists.length === 0) return null;

    const mergeTwoLists = (l1, l2) => {
        if (!l1) return l2;
        if (!l2) return l1;

        let head = null;
        if (l1.val < l2.val) {
            head = l1;
            l1 = l1.next;
        } else {
            head = l2;
            l2 = l2.next;
        }

        let current = head;
        while (l1 && l2) {
            if (l1.val < l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }

        current.next = l1 || l2;
        return head;
    };

    while (lists.length > 1) {
        const mergedLists = [];
        for (let i = 0; i < lists.length; i += 2) {
            const l1 = lists[i];
            const l2 = lists[i + 1];
            mergedLists.push(mergeTwoLists(l1, l2));
        }
        lists = mergedLists;
    }

    return lists[0] || null;
};",This code implements a solution to merge k sorted linked lists using the divide-and-conquer approach. It leverages a helper function mergeTwoLists to merge two lists at a time. The main function iteratively merges pairs of lists until only one list remains. Error handling is included to manage empty or null input. The code is organized for readability and uses modern JavaScript syntax.
"/**
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function(word1, word2) {
 let result = '';
  for (let i = 0; i < Math.max(word1.length, word2.length); i++) {
    if (i < word1.length) result += word1[i];
    if (i < word2.length) result += word2[i];
  }
  return result;
};",Easy,"/**
 * @param {string} word1
 * @param {string} word2
 * @return {string} 
 */
var mergeAlternately = function(word1, word2) {
    let merged = """";
    let i = 0;
    let j = 0;
    while (i < word1.length || j < word2.length) {
        if (i < word1.length) {
            merged += word1[i];
            i++;
        }
        if (j < word2.length) {
            merged += word2[j];
            j++;
        }
    }
    return merged;
};","This code iterates through both strings using two pointers, i and j, respectively. In each iteration, it appends the current character from word1 (if within bounds) to the merged string, then does the same for word2. This alternating append continues until both pointers have reached the end of their respective strings. The resulting merged string is then returned."
"var gcdOfStrings = function (str1, str2) {
    // handle the base case
    if (str1 + str2 !== str2 + str1) return '';
    let a = str1.length
    let b = str2.length

    // loop (divide) until you find the 
    // highest common factor (length of string) 
    // like we did in maths
    while (b) {
        let temp = b
        b = a % b
        a = temp
    }
    return str1.substring(0, a)
};",Easy,"/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
    if (str1 + str2 !== str2 + str1) {
        return """";
    }

    let gcd = (a, b) => {
        while (b) {
            let temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    };

    return str1.substring(0, gcd(str1.length, str2.length));
};","The provided code efficiently determines the greatest common divisor (GCD) of two strings, str1 and str2. It begins by checking if the concatenation of str1 and str2 is equal to the concatenation of str2 and str1. If they aren't equal, it signifies that no common divisor exists, and an empty string is returned. Otherwise, a Euclidean algorithm-based GCD function is employed to find the GCD of the lengths of the two strings. Finally, a substring of str1, from the beginning up to the calculated GCD length, is returned as the largest common divisor of both strings. This approach ensures correctness and efficiency in identifying the largest string that divides both input strings."
"var reverseWords = function(s) {
    let words = s.split(' ');
    let res = [];

    for (let i = words.length - 1; i >= 0; i--) {
        if (words[i]) {
            res.push(words[i]);
        }
    }

    return res.join(' ');
};",Medium,"/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    // Trim leading and trailing spaces
    s = s.trim();

    // Split the string into words
    const words = s.split(/\s+/);

    // Reverse the array of words
    const reversedWords = words.reverse();

    // Join the reversed words with a single space
    const reversedString = reversedWords.join(' ');

    // Return the reversed string
    return reversedString;
};","The solution trims the input string to remove leading/trailing spaces and then splits the string into an array of words using the split method with a regular expression that matches one or more whitespace characters. The order of words in the array is reversed using the reverse method. Finally, the reversed words are joined back into a single string with single spaces using the join method. This approach handles multiple spaces between words effectively and ensures that the returned string has only single spaces separating the words."
"var productExceptSelf = function(nums) {
    const output = Array(nums.length).fill(1);

    let left = 1;
    for (let i = 0; i < nums.length; i++) {
        output[i] *= left;
        left *= nums[i];
    }

    let right = 1;
    for (let i = nums.length - 1; i >= 0; i--) {
        output[i] *= right;
        right *= nums[i];
    }

    return output;    
};",Medium,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    const n = nums.length;
    const result = new Array(n).fill(1);

    // Calculate prefix products
    let prefixProduct = 1;
    for (let i = 0; i < n; i++) {
        result[i] = prefixProduct;
        prefixProduct *= nums[i];
    }

    // Calculate suffix products and multiply with prefix products
    let suffixProduct = 1;
    for (let i = n - 1; i >= 0; i--) {
        result[i] *= suffixProduct;
        suffixProduct *= nums[i];
    }

    return result;
};","This code calculates the product of all elements except self without using division and in O(n) time. It uses two passes: one to calculate prefix products and store them in the result array, and another to calculate suffix products and multiply them with the corresponding prefix products already stored in the result. This approach avoids division and efficiently computes the desired output."
"/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
    let write = 0;
    let read = 0;

    while (read < chars.length) {
        let char = chars[read];
        let count = 0;

        // Count the number of consecutive characters
        while (read < chars.length && chars[read] === char) {
            count++;
            read++;
        }
        chars[write] = char;
        write++;
        if (count > 1) {
            for (let digit of String(count)) {
                chars[write] = digit;
                write++;
            }
        }
    }

    return write;
};",Medium,"/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
    if (!chars || chars.length === 0) {
        return 0;
    }

    let writeIndex = 0;
    let readIndex = 0;

    while (readIndex < chars.length) {
        const currentChar = chars[readIndex];
        let count = 0;

        while (readIndex < chars.length && chars[readIndex] === currentChar) {
            readIndex++;
            count++;
        }

        chars[writeIndex++] = currentChar;

        if (count > 1) {
            const countStr = count.toString();
            for (const digit of countStr) {
                chars[writeIndex++] = digit;
            }
        }
    }

    return writeIndex;
};","This code iterates through the input array 'chars', keeping track of consecutive repeating characters. A 'writeIndex' maintains the position for writing the compressed characters back into the array. When a group of repeating characters is encountered, the character and its count (if greater than 1) are written to the array. The function returns the new length of the modified array, indicated by 'writeIndex'."
"/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var longestOnes = function(nums, k) {
    let left = 0
    let max_length = 0
    let zero_count = 0
    for (let right = 0; right < nums.length; right++) {
        if(nums[right] == 0){
            zero_count += 1
        }
        while(zero_count > k) {
            if(nums[left] == 0) {
                zero_count -= 1
            }
            left++
        }
        // Calculate the length of the current valid window 
        // and update max_length
        max_length = Math.max(max_length, right- left + 1)
    }
    return max_length
};",Medium,"/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var longestOnes = function(nums, k) {
    let left = 0;
    let right = 0;
    let maxConsecutiveOnes = 0;
    let zerosFlipped = 0;

    while (right < nums.length) {
        if (nums[right] === 0) {
            zerosFlipped++;
        }

        while (zerosFlipped > k) {
            if (nums[left] === 0) {
                zerosFlipped--;
            }
            left++;
        }

        maxConsecutiveOnes = Math.max(maxConsecutiveOnes, right - left + 1);
        right++;
    }

    return maxConsecutiveOnes;
};","This code implements a sliding window approach. The `left` and `right` pointers define the window's boundaries. The `zerosFlipped` variable tracks the number of zeros within the current window. The outer loop expands the window by moving the `right` pointer. If a zero is encountered, `zerosFlipped` is incremented. The inner loop shrinks the window from the left until `zerosFlipped` is no longer greater than `k`. The `maxConsecutiveOnes` variable keeps track of the maximum window size seen so far. This approach efficiently finds the longest subarray with at most k zeros."
"/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[][]}
 */
var findDifference = function(nums1, nums2) {
    let set1 = new Set(nums1);
    let set2 = new Set(nums2);
    let uniqueToNums1 = Array.from(set1).filter(x => !set2.has(x));
    let uniqueToNums2 = Array.from(set2).filter(x => !set1.has(x));

    return [uniqueToNums1, uniqueToNums2];
};",Medium,"/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[][]}
 */
var findDifference = function(nums1, nums2) {
    const set1 = new Set(nums1);
    const set2 = new Set(nums2);
    const diff1 = [];
    const diff2 = [];

    for (const num of set1) {
        if (!set2.has(num)) {
            diff1.push(num);
        }
    }

    for (const num of set2) {
        if (!set1.has(num)) {
            diff2.push(num);
        }
    }

    return [diff1, diff2];
};","This code leverages Sets for efficient lookups. It initializes two sets, set1 and set2, with the elements of nums1 and nums2 respectively. Then, it iterates through each set, checking if an element is present in the other set using the has() method. If an element is not found in the other set, it's added to the corresponding difference array (diff1 or diff2). Finally, the function returns a 2D array containing the two difference arrays."
"/**
 * @param {string} s
 * @return {string}
 */
var removeStars = function(s) {
let i = 0;
    let stk = [];
     while(i<s.length){
         if(s.charAt(i)===""*""){
            if(stk.length>0){
                stk.pop();
            }
         }
         else {
             stk.push(s.charAt(i))
         }
         i++;
     }
    return stk.join("""");
};",Medium,"/**
 * @param {string} s
 * @return {string}
 */
var removeStars = function(s) {
    let stack = [];
    for (let char of s) {
        if (char === '*') {
            stack.pop();
        } else {
            stack.push(char);
        }
    }
    return stack.join('');
};","This code iterates through the input string 's'. If a character is a star, it pops the last element from the stack, effectively removing the closest non-star character to its left and the star itself. Otherwise, the character is pushed onto the stack. Finally, the remaining characters in the stack are joined to form the resulting string. This approach ensures that the operations are performed according to the problem description and handles all stars efficiently."
"var predictPartyVictory = function(senate) {
    senate = senate.split('');
    while(senate.length) {
        var first = senate.shift();
        var len = senate.length;

        for(var i=0; i<len; i++) {
            if(first != senate[i]) {
                senate.splice(i, 1);
                senate.push(first);
                break;
            }
        }
        if(i == len) {
            return first == 'D' ? 'Dire' : 'Radiant';
        }
    }
};",Medium,"/**
 * @param {string} senate
 * @return {string}
 */
var predictPartyVictory = function(senate) {
    let n = senate.length;
    let radiant = [];
    let dire = [];
    let banned = new Array(n).fill(false);

    for (let i = 0; i < n; i++) {
        if (senate[i] === 'R') {
            radiant.push(i);
        } else {
            dire.push(i);
        }
    }

    while (radiant.length > 0 && dire.length > 0) {
        let r_idx = radiant.shift();
        let d_idx = dire.shift();

        if (!banned[r_idx] && !banned[d_idx]) {
            if (r_idx < d_idx) {
                radiant.push(r_idx + n);
                banned[d_idx] = true;
            } else {
                dire.push(d_idx + n);
                banned[r_idx] = true;
            }
        } else if (!banned[r_idx]) {
            radiant.push(r_idx + n);
        } else if (!banned[d_idx]) {
            dire.push(d_idx + n);
        }
    }

    return radiant.length > 0 ? ""Radiant"" : ""Dire"";
};","This code simulates the voting process using queues for Radiant and Dire senators. Senators ban opponents based on their index in the original senate string. A 'banned' array tracks banned senators. The simulation continues until one party has no remaining senators.  The function returns ""Radiant"" if the Radiant party wins, and ""Dire"" otherwise. This approach efficiently handles the round-based banning process and ensures that the correct winning party is determined based on the given rules."
"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    if(head === null)return null;
    prev = new ListNode(0);
    prev.next = head;
    slow = prev;
    fast = head;
    while(fast != null && fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    slow.next = slow.next.next;
    return prev.next;
};",Medium,"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    if (!head || !head.next) return null; // Handle empty or single-node list

    let slow = head;
    let fast = head;
    let prev = null;

    while (fast && fast.next) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }

    prev.next = slow.next; // Skip the middle node

    return head;
};","The provided code efficiently removes the middle node from a singly linked list. It uses the fast and slow pointer technique. The fast pointer moves two steps at a time while the slow pointer moves one step. When the fast pointer reaches the end, the slow pointer is at the middle. We use a 'prev' pointer to keep track of the node before the slow pointer so that we can easily skip the middle node by adjusting the 'next' pointers."
"function lowestCommonAncestor(root, p, q) {
  if (!root || root === p || root === q) return root;
  var resL = lowestCommonAncestor(root.left, p, q);
  var resR = lowestCommonAncestor(root.right, p, q);
  return (resL && resR) ? root : (resL || resR);
}",Medium,"/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (!root || root === p || root === q) {
        return root;
    }

    const leftLCA = lowestCommonAncestor(root.left, p, q);
    const rightLCA = lowestCommonAncestor(root.right, p, q);

    if (leftLCA && rightLCA) {
        return root; // Both nodes found in different subtrees
    }

    return leftLCA || rightLCA; // One or both nodes found in a single subtree
};","This code implements a recursive approach to find the LCA. It checks three base cases: if the current node is null, p, or q, then it returns the current node. Otherwise, it recursively searches the left and right subtrees. If both p and q are found in different subtrees, the current node is the LCA. If p and q are found in the same subtree, the LCA is returned from that subtree."
"var findCircleNum = function (isConnected) {

    let provinces = 0;
    let visited = new Array(isConnected.length).fill(false);

    for (let i = 0; i < isConnected.length; i++) {
        if (!visited[i]) {
            provinces++;
            dfs(isConnected, visited, i);
        }
    }
    return provinces;
};

function dfs(isConnected, visited, i) {

    visited[i] = true;
    
    for (let j = 0; j < isConnected.length; j++) {
        if (isConnected[i][j] === 1 && !visited[j]) {
            dfs(isConnected, visited, j);
        }
    }
}",Medium,"/**
 * @param {number[][]} isConnected
 * @return {number}
 */
var findCircleNum = function(isConnected) {
    if (!isConnected || isConnected.length === 0) {
        return 0; // Handle empty input
    }

    const n = isConnected.length;
    const visited = new Array(n).fill(false);
    let provinces = 0;

    const dfs = (city) => {
        visited[city] = true;
        for (let neighbor = 0; neighbor < n; neighbor++) {
            if (isConnected[city][neighbor] === 1 && !visited[neighbor]) {
                dfs(neighbor);
            }
        }
    };

    for (let i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
            provinces++;
        }
    }

    return provinces;
};","This code uses Depth-First Search (DFS) to find the number of provinces.  It initializes a visited array to keep track of visited cities. The main loop iterates through each city. If a city hasn't been visited, it performs DFS starting from that city, marking all reachable cities as visited. Each time a new DFS starts, it signifies a new province. The function returns the total count of provinces. Error handling is included for an empty input array."
"var findPeakElement = function(nums) {
    var start = 0, end = nums.length - 1;
    while (start < end) {
        var mid = Math.floor((start + end) / 2);
        if (mid === 0) {
            return nums[0] >= nums[1] ? 0 : 1;
        }
        if (mid === end) {
            return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;
        }

        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
            return mid;
        }
        if (nums[mid] < nums[mid - 1]) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    return start;
};",Medium,"/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    let left = 0;
    let right = nums.length - 1;

    while (left < right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] > nums[mid + 1]) {
            // We are on a descending slope, so the peak must be to the left
            // or at mid itself.
            right = mid;
        } else {
            // We are on an ascending slope, so the peak must be to the right.
            left = mid + 1;
        }
    }

    // At this point, left and right will converge to a peak element's index.
    return left;
};","This solution uses a binary search approach to find a peak element in O(log n) time. The core idea is to compare the middle element with its right neighbor. If the middle element is greater, then a peak element must exist in the left half (including the middle element). Otherwise, a peak element must exist in the right half. This process is repeated until the search space converges to a single element, which is guaranteed to be a peak element due to the given constraints."
"var twoSum = function(nums, target) {
    
    let numToIndexMap = {};

    
    for (let i = 0; i < nums.length; i++) {
        
        let diff = target - nums[i];

        
        if (numToIndexMap.hasOwnProperty(diff)) {
            
            return [i, numToIndexMap[diff]];
        }

        
        numToIndexMap[nums[i]] = i;
    }

    
    return null;
};",Easy,"/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    if (!Array.isArray(nums) || !nums.length || typeof target !== 'number') {
        throw new Error(""Invalid input. Please provide a non-empty array of numbers and a target number."");
    }

    const numMap = new Map();

    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];

        if (numMap.has(complement)) {
            return [numMap.get(complement), i];
        }

        numMap.set(nums[i], i);
    }

    return []; // No solution found
};","This code utilizes a Map to store each number encountered in the array along with its index. For every number in the input array, it calculates the complement needed to reach the target. It then checks if the complement exists in the Map. If found, it returns the indices of the current number and its complement. If no solution is found after iterating through the entire array, an empty array is returned. This approach offers a time complexity of O(n) due to the single pass through the array and constant-time lookups in the Map."
"var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }
    
    var freq = new Array(26).fill(0);
    for (var i = 0; i < s.length; i++) {
        freq[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
        freq[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }
    
    for (var i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }
    
    return true;
};",Easy,"/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }

    const sCharCounts = {};
    const tCharCounts = {};

    for (let i = 0; i < s.length; i++) {
        sCharCounts[s[i]] = (sCharCounts[s[i]] || 0) + 1;
        tCharCounts[t[i]] = (tCharCounts[t[i]] || 0) + 1;
    }

    for (const char in sCharCounts) {
        if (sCharCounts[char] !== tCharCounts[char]) {
            return false;
        }
    }

    return true;
};","This code checks if two strings 's' and 't' are anagrams of each other. It first handles the edge case where the lengths of the strings are different, returning 'false' if they don't match. Then, it initializes two objects, 'sCharCounts' and 'tCharCounts', to store character counts for each string. It iterates through both strings, incrementing the character counts in the respective objects. Finally, it iterates through the keys of 'sCharCounts' and checks if the counts match in 'tCharCounts'. If any count doesn't match, it returns 'false'. Otherwise, it returns 'true' after checking all characters."
"var romanToInt = function(s) {
    let res = 0;
    const roman = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    };

    for (let i = 0; i < s.length - 1; i++) {
        if (roman[s[i]] < roman[s[i + 1]]) {
            res -= roman[s[i]];
        } else {
            res += roman[s[i]];
        }
    }

    return res + roman[s[s.length - 1]];    
};",Easy,"/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    const romanMap = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    };

    let result = 0;
    for (let i = 0; i < s.length; i++) {
        const currentVal = romanMap[s[i]];
        const nextVal = romanMap[s[i + 1]];

        if (nextVal && currentVal < nextVal) {
            result -= currentVal;
        } else {
            result += currentVal;
        }
    }

    return result;
};","This code iterates through the Roman numeral string, checking if the current numeral's value is less than the next one. If it is, the current value is subtracted (e.g., IV = -1 + 5 = 4). Otherwise, the current value is added. This approach efficiently handles the subtractive cases of Roman numerals while maintaining a clean and readable code structure."
"var isPalindrome = function(x) {
    if (x < 0) {
        return false;
    }

    let reverse = 0;
    let xcopy = x;

    while (x > 0) {
        reverse = (reverse * 10) + (x % 10);
        x = Math.floor(x / 10);
    }

    return reverse === xcopy;    
};",Easy,"/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x < 0) {
        return false; // Negative numbers are not palindromes
    }

    const original = x;
    let reversed = 0;

    while (x > 0) {
        reversed = (reversed * 10) + (x % 10);
        x = Math.floor(x / 10);
    }

    return original === reversed;
};","This code checks if a given integer x is a palindrome. It first handles the edge case of negative numbers, which cannot be palindromes. Then, it reverses the integer x using a while loop and stores it in the reversed variable. Finally, it compares the original integer with the reversed integer and returns true if they are equal, and false otherwise. The approach of reversing the integer and comparing it with the original is efficient and easy to understand."
"/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var ans = [];

    for (var i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            ans.push(""FizzBuzz"");
        } else if (i % 3 === 0) {
            ans.push(""Fizz"");
        } else if (i % 5 === 0) {
            ans.push(""Buzz"");
        } else {
            ans.push(i.toString());
        }
    }

    return ans;
};",Easy,"/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    if (typeof n !== 'number' || !Number.isInteger(n) || n < 1) {
        throw new Error(""Input must be a positive integer."");
    }
    const result = [];
    for (let i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            result.push(""FizzBuzz"");
        } else if (i % 3 === 0) {
            result.push(""Fizz"");
        } else if (i % 5 === 0) {
            result.push(""Buzz"");
        } else {
            result.push(i.toString());
        }
    }
    return result;
};","This code iterates from 1 to n. In each iteration, it checks if the current number (i) is divisible by 3 and/or 5 using the modulo operator (%). If divisible by both 3 and 5, it pushes ""FizzBuzz"" to the result array. If divisible by only 3, it pushes ""Fizz"". If divisible by only 5, it pushes ""Buzz"". Otherwise, it pushes the number itself (converted to a string) to the result array. Error handling is included to validate the input n, ensuring it's a positive integer. This approach is efficient and follows best practices for code clarity and organization."
"/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    const hash = {};
    let res = 0;
    let majority = 0;

    for (let n of nums) {
        hash[n] = 1 + (hash[n] || 0);
        if (hash[n] > majority) {
            res = n;
            majority = hash[n];
        }
    }

    return res;    
};",Easy,"/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    if (!nums || nums.length === 0) {
        return null; // Or throw an error: throw new Error(""Input array is invalid."");
    }

    let candidate = null;
    let count = 0;

    for (const num of nums) {
        if (count === 0) {
            candidate = num;
        }
        count += (num === candidate) ? 1 : -1;
    }

    return candidate;
};","This code implements the Boyer-Moore Voting Algorithm. It's highly efficient, with a time complexity of O(n) and constant space complexity. The algorithm works by maintaining a 'candidate' and a 'count'.  It iterates through the array, incrementing the count if the current element matches the candidate and decrementing it otherwise. If the count reaches zero, the next element becomes the new candidate.  Due to the majority element's frequency, it will always emerge as the final candidate."
"
var firstUniqChar = function(s) {
    let mp = {};

    for (let a of s) {
        mp[a] = (mp[a] || 0) + 1;
    }

    for (let i = 0; i < s.length; i++) {
        if (mp[s[i]] === 1) {
            return i;
        }
    }

    return -1;
};",Easy,"/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    const charCount = new Map();

    for (const char of s) {
        charCount.set(char, (charCount.get(char) || 0) + 1);
    }

    for (let i = 0; i < s.length; i++) {
        if (charCount.get(s[i]) === 1) {
            return i;
        }
    }

    return -1;
};","This code iterates through the input string 's' using a Map to store character counts. The first loop counts each character's occurrences. The second loop checks for the first character with a count of 1 and returns its index. If no such character is found, it returns -1. This approach is efficient with O(n) time complexity as it iterates through the string twice at most."
"function binarySearch(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}",Easy,"/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
};","This code implements the binary search algorithm. 
1. Initialize left and right pointers to the start and end of the array respectively.
2. While left is less than or equal to right:
    a. Calculate the middle index.
    b. If the element at the middle index is equal to the target, return the middle index.
    c. If the element at the middle index is less than the target, move the left pointer to mid + 1.
    d. If the element at the middle index is greater than the target, move the right pointer to mid - 1.
3. If the target is not found, return -1."
"var moveZeroes = function(nums) {
    let left = 0;

    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== 0) {
            [nums[right], nums[left]] = [nums[left], nums[right]];
            left++;
        }
    }

    return nums;    
};",Easy,"/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    if (!Array.isArray(nums)) {
        throw new TypeError(""Input must be an array."");
    }
    let left = 0; // Pointer to track the position for placing non-zero elements
    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== 0) {
            // If the current element is non-zero, swap it with the element at the left pointer
            if (left !== right) {
                [nums[left], nums[right]] = [nums[right], nums[left]];
            }
            left++; // Increment the left pointer
        }
    }
};","This code uses the two-pointer approach. The ""left"" pointer keeps track of the index where the next non-zero element should be placed. The ""right"" pointer iterates through the array. When a non-zero element is encountered, it's swapped with the element at the ""left"" pointer, and the ""left"" pointer is incremented. This ensures that all non-zero elements are moved to the beginning of the array in their original order, while the zeroes are effectively shifted to the end. Error handling is included to check for valid array input."
"/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(input) {
    var start = 0
    var end = input.length - 1
    while (start < end) {
        var s = input.charCodeAt(start)
        var e = input.charCodeAt(end)
    
        if (!isLetter(s)) {
            start++
            continue
        }
        if (!isLetter(e)) {
            end--
            continue
        }
    
        if (toLowerCase(s) !== toLowerCase(e)) {
            return false 
        } 
        start++
        end--
  }
  return true
};

var isLetter = function(code) {
    if (((code >= 48) && (code <= 57))  // numbers
    || ((code >= 65) && (code <= 90))  // uppercase
    || ((code >= 97) && (code <= 122))) {  // lowercase
        return true
    }
    else {
        return false
    }
}

var toLowerCase = function(code) {
    if (code >= 65 && code <= 90) {
        return code + 32    
    }
    else {
        return code
    }
}",Easy,"/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    s = s.toLowerCase().replace(/[^a-z0-9]/g, '');
    let left = 0;
    let right = s.length - 1;
    while (left < right) {
        if (s[left] !== s[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
};","The provided JavaScript code checks if a given string \""s\"" is a palindrome. It first converts the input string to lowercase and removes any non-alphanumeric characters using a regular expression. Then, it uses a two-pointer approach with \""left\"" and \""right\"" pointers to compare characters from both ends of the cleaned string. If any mismatch is found, it returns \""false\"". Otherwise, if the loop completes without finding any mismatches, it returns \""true\"". This approach efficiently handles various edge cases and ensures that only alphanumeric characters are considered during the palindrome check."
"var isPowerOfThree = function(n) {
    if (n === 0) return false;
    if (n === 1) return true;
    
    if (!(n%3)) return isPowerOfThree(n/3);
    
    return false;
};",Easy,"/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    if (n <= 0) {
        return false;
    }

    while (n % 3 === 0) {
        n /= 3;
    }

    return n === 1;
};","This code checks if a given integer n is a power of three. It handles edge cases by returning 'false' for non-positive inputs. It iteratively divides n by 3 as long as it's divisible, and finally checks if the result is 1. This approach efficiently determines if n can be expressed as 3 raised to an integer power."
"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    let obj={}
    for(let n of nums){
        obj[n]=1
    }
    let arr=[]
    for(let i=1;i<=nums.length;i++){
        if(!obj[i]) arr.push(i)
    }
    return arr
};",Easy,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    if (!Array.isArray(nums)) {
        throw new TypeError(""Input must be an array."");
    }
    if (!nums.every(num => typeof num === 'number')) {
        throw new TypeError(""Array elements must be numbers."");
    }

    const n = nums.length;
    const present = new Set();
    for (const num of nums) {
        present.add(num);
    }

    const missing = [];
    for (let i = 1; i <= n; i++) {
        if (!present.has(i)) {
            missing.push(i);
        }
    }

    return missing;
};","This code iterates through the input array `nums` and adds each number to a `Set` called `present`. Then, it iterates from 1 to `n` (the length of `nums`) and checks if each number is present in the `Set`. If a number is not present, it's added to the `missing` array. This approach has a time complexity of O(n) because it iterates through the input array and the range [1, n] once. The space complexity is also O(n) in the worst case, where all numbers in the range [1, n] are missing, due to storing up to n numbers in the set and missing array. Error handling is included to check for invalid input types."
"/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    cost.push(0);

    for (let i = cost.length - 4; i >= 0; i--) {
        cost[i] += Math.min(cost[i + 1], cost[i + 2]);
    }

    return Math.min(cost[0], cost[1]);    
};",Easy,"/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    const dp = new Array(n + 1).fill(0);

    for (let i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }

    return dp[n];
};","This code uses dynamic programming to determine the minimum cost to reach the top of the stairs. `dp[i]` stores the minimum cost to reach step `i`. The code iterates through the `cost` array, calculating the minimum cost to reach each step by considering either taking one step from the previous step or two steps from the step before that. The final result is stored in `dp[n]`, which represents the minimum cost to reach the top (step `n`). The base cases `dp[0]` and `dp[1]` are initialized to 0 because they represent the starting steps, which have no cost to reach."
"/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    let res = """";
    let x=0, y=0, rem=0;
    while(a!="""" || b!="""") {
        if(a!="""") {
            x = parseInt(a.slice(-1));
            a = a.slice(0,-1);
        }
        if(b!="""") {
            y = parseInt(b.slice(-1));
            b = b.slice(0,-1);
        }
        if(x+y+rem == 2) {
            rem=1;
            res = ""0"" + res;
        }
        else if(x+y+rem == 3) {
            rem=1;
            res = ""1"" + res;
        }
        else {
            res = (x+y+rem).toString() + res;
            rem=0;
        }
        x=0;
        y=0;
    }
    if(rem==1) res = ""1"" + res;
    return res;

};",Easy,"/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    let i = a.length - 1;
    let j = b.length - 1;
    let carry = 0;
    let result = """";

    while (i >= 0 || j >= 0 || carry) {
        const digitA = i >= 0 ? parseInt(a[i]) : 0;
        const digitB = j >= 0 ? parseInt(b[j]) : 0;
        const sum = digitA + digitB + carry;
        const remainder = sum % 2;
        carry = Math.floor(sum / 2);
        result = remainder.toString() + result;
        i--;
        j--;
    }

    return result;
};","This code iterates through the binary strings `a` and `b` from right to left, simulating the binary addition process. It maintains a `carry` variable to handle overflows. In each iteration, it calculates the sum of corresponding digits and the carry, appends the remainder to the `result` string, and updates the carry. The loop continues until all digits and the carry are processed.  Error handling is implicitly managed by JavaScript's loose typing system; invalid input will produce a numerical result of NaN, which will propagate through the calculation and return a nonsensical string. This approach prioritizes conciseness and efficiency."
"/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    const seen = new Set();
    
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        let sum = 0;
        
        let numStr = n.toString();
        for (let i = 0; i < numStr.length; i++) {
            let digit = Number(numStr[i]);
            sum += digit * digit;
        }
        
        n = sum;  
    }
    return n === 1;
};",Easy,"/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    const seen = new Set();
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        n = sumOfSquares(n);
    }
    return n === 1;

    function sumOfSquares(num) {
        let sum = 0;
        while (num > 0) {
            const digit = num % 10;
            sum += digit * digit;
            num = Math.floor(num / 10);
        }
        return sum;
    }
};","This code implements the happy number algorithm by repeatedly calculating the sum of squares of digits until either 1 is reached or a cycle is detected. A Set is used to efficiently track seen numbers. The sumOfSquares helper function calculates the sum of squares of digits for a given number. The main function returns true if the number is happy (eventually reaches 1), and false otherwise (enters a cycle). Error handling is implicitly handled by JavaScript's number type system."
"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    if (!root) return 0
    let leftSubHeight = maxDepth(root.left)
    let rightSubHeight = maxDepth(root.right) 
    return Math.max(leftSubHeight, rightSubHeight) + 1
};",Easy,"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0;

    const leftDepth = maxDepth(root.left);
    const rightDepth = maxDepth(root.right);

    return Math.max(leftDepth, rightDepth) + 1;
};","This code uses a recursive approach to find the maximum depth of a binary tree.  The base case is when the root is null, in which case the depth is 0. Otherwise, the function recursively calculates the maximum depth of the left and right subtrees. The maximum depth of the current node is then 1 plus the maximum of the left and right subtree depths. This approach effectively explores all paths from the root to leaf nodes and determines the longest one."
"/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  
    let nodeA = headA;
    let nodeB = headB;
    
    
    while (nodeA !== nodeB) {
        
        nodeA = !nodeA ? headB : nodeA.next;
        
        nodeB = !nodeB ? headA : nodeB.next;
    }
    
    
    return nodeA;
};",Easy,"/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    let pA = headA;
    let pB = headB;

    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }

    return pA;
};","This code uses a two-pointer approach to find the intersection of two linked lists.  Two pointers, pA and pB, are initialized to the heads of the two lists respectively. In a while loop, the pointers traverse their respective lists. If a pointer reaches the end of its list, it's redirected to the head of the other list. This ensures that both pointers will eventually meet at the intersection point (if one exists) or both become null if there is no intersection. The time complexity of this approach is O(m+n) where m and n are the lengths of the two lists, and the space complexity is O(1) as it uses only two pointers."
"var minDistance = function(word1, word2) {
    const cache = {}
    function dp(i, j) {
        if (cache[`${i}->${j}`] !== undefined) {
            return cache[`${i}->${j}`]
        }
        if (i >= word1.length) {
            return word2.length - j;
        } 
        if (j >= word2.length) {
            return word1.length - i;
        }
        if (word1[i] === word2[j]) {
            return dp(i+1, j+1);
        }
        let insert = 1 + dp(i, j+1);
        let del = 1 + dp(i+1, j);
        let repl = 1 + dp(i+1, j+1);
        const res = Math.min(insert, del, repl);
        cache[`${i}->${j}`] = res;
        return res;
    }
    return dp(0, 0)
};",Medium,"/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
    const m = word1.length;
    const n = word2.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }

    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1, // deletion
                    dp[i][j - 1] + 1, // insertion
                    dp[i - 1][j - 1] + 1 // replacement
                );
            }
        }
    }

    return dp[m][n];
};","This code implements the dynamic programming approach to solve the edit distance problem. It initializes a 2D array dp where dp[i][j] represents the minimum number of operations to convert word1[0...i-1] to word2[0...j-1]. The code iterates through the array, calculating each value based on the three possible operations (insertion, deletion, replacement) and the previous values in the array. The final result is stored in dp[m][n]."
"/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if(!nums.length) return 0;
    
    let count = 1;
    let largestSequence = 0;
    
    nums = new Set(nums);
    nums = Array.from(nums);
    nums.sort((a,b)=> a-b);
   

    for(let i=0 ; i<nums.length ; i++){
        let diff = nums[i+1] - nums[i]; 
        if(diff == 1){
             count++;
        }else{
            if(count > largestSequence){
                largestSequence = count;
            }
            count = 1;
        }

    }
    return largestSequence;;
};",Medium,"/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if (!nums || nums.length === 0) {
        return 0;
    }

    const numSet = new Set(nums);
    let longestStreak = 0;

    for (const num of numSet) {
        if (!numSet.has(num - 1)) { // Check if it's the start of a sequence
            let currentNum = num;
            let currentStreak = 1;

            while (numSet.has(currentNum + 1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }

    return longestStreak;
};","This code implements the O(n) solution using a Set. It first handles the edge case of an empty or null input array. Then, it creates a Set from the input array for efficient lookups. It iterates through the Set. For each number, it checks if it's the start of a consecutive sequence (by checking if num-1 exists). If it is, it iterates while incrementing the current number and streak length. Finally, it updates the longestStreak if a longer sequence is found. This approach ensures each number is visited at most twice, resulting in O(n) time complexity."
"var shortestPalindrome = function(s) {
    let count = kmp(s.split('').reverse().join(''), s);
    return s.slice(count).split('').reverse().join('') + s;
};

var kmp = function(txt, patt) {
    let newString = patt + '#' + txt;
    let pi = new Array(newString.length).fill(0);
    let i = 1, k = 0;
    while (i < newString.length) {
        if (newString[i] === newString[k]) {
            k++;
            pi[i] = k;
            i++;
        } else {
            if (k > 0) {
                k = pi[k - 1];
            } else {
                pi[i] = 0;
                i++;
            }
        }
    }
    return pi[newString.length - 1];
};",Hard,"/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
  if (!s) return """";

  let n = s.length;
  let reversedS = s.split('').reverse().join('');
  let lps = calculateLPS(s + '#' + reversedS);

  let prefixLength = lps[lps.length - 1];
  let suffix = s.substring(prefixLength);
  let reversedSuffix = suffix.split('').reverse().join('');

  return reversedSuffix + s;
};

function calculateLPS(s) {
  let n = s.length;
  let lps = new Array(n).fill(0);

  for (let i = 1; i < n; i++) {
    let j = lps[i - 1];
    while (j > 0 && s[i] !== s[j]) {
      j = lps[j - 1];
    }
    if (s[i] === s[j]) {
      j++;
    }
    lps[i] = j;
  }
  return lps;
}","This code efficiently finds the shortest palindrome by prepending characters. It utilizes the KMP algorithm's longest proper prefix suffix (LPS) calculation to determine the longest palindrome prefix in the given string. By calculating the LPS array of the concatenated string (original + '#' + reversed), we can identify the length of the longest palindrome prefix. The remaining suffix is then reversed and prepended to the original string to form the shortest palindrome. This approach avoids unnecessary character additions and provides an optimal solution."
"var findLadders = function(beginWord, endWord, wordList) {
    if (!wordList.includes(endWord)) return [];
    
    const result = [], map = new Map(), steps = new Map();
	
    for (const word of wordList) {
        for (let i = 0; i < word.length; i++) {
            const hash = word.substring(0, i) + '*' + word.substring(i + 1);
			
            if (!map.has(hash)) map.set(hash, []);
			
            map.get(hash).push(word);
            steps.set(hash, wordList.length);
        }
    }
    
    const queue = [[beginWord]];
	
    while (queue.length > 0) {
        const current = queue.shift();
        const set = new Set(current);
        const lastWord = current[current.length - 1];
        if (lastWord === endWord) {
            if (result.length === 0 || current.length === result[0].length)
                result.push(current);
            else break;
        } else {
            for (let i = 0; i < lastWord.length; i++) {
                const hash = lastWord.substring(0, i) + '*' + lastWord.substring(i + 1);
                if (!map.has(hash) || current.length > steps.get(hash))
					continue;
					
                for (const nextWord of map.get(hash))
                    if (!set.has(nextWord))
						queue.push([...current, nextWord]);
						
                steps.set(hash, current.length);
            }
        }
    }
    return result;
};",Hard,"/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    if (!wordList.includes(endWord)) return [];

    const adjList = new Map();
    const visited = new Set();
    const queue = [[beginWord, [beginWord]]];
    const result = [];
    let minLength = Infinity;

    for (const word of wordList) {
        for (let i = 0; i < word.length; i++) {
            const pattern = word.slice(0, i) + '*' + word.slice(i + 1);
            adjList.set(pattern, adjList.get(pattern) || []);
            adjList.get(pattern).push(word);
        }
    }

    while (queue.length) {
        const [currWord, path] = queue.shift();
        if (path.length > minLength) continue; // Optimization

        if (currWord === endWord) {
            minLength = path.length;
            result.push([...path]);
            continue;
        }

        visited.add(currWord);

        for (let i = 0; i < currWord.length; i++) {
            const pattern = currWord.slice(0, i) + '*' + currWord.slice(i + 1);
            if (adjList.has(pattern)) {
                for (const neighbor of adjList.get(pattern)) {
                    if (!visited.has(neighbor)) {
                        queue.push([neighbor, [...path, neighbor]]);
                    }
                }
            }
        }
    }

    return result;
};","This code uses a breadth-first search (BFS) approach to find the shortest transformation sequences. It constructs an adjacency list using patterns with '*' representing a single character difference. The BFS explores possible paths, keeping track of the shortest path length.  When the endWord is reached, the current path is added to the result if its length is the shortest found so far. The visited set prevents cycles and redundant explorations.  The code includes an optimization to prune longer paths during the BFS."
"const isMatch = function (string, pattern) {
  let s = 0, p = 0;
  let starIdx = -1, pointer = -1;

  while (s < string.length) {
    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === ""?"") {
      s++;
      p++;
    } 
	else if (p < pattern.length && pattern[p] === ""*"") {
      starIdx = p;
      pointer = s;
      p++;
    } 
	else if (starIdx === -1) return false;
    else {
      p = starIdx + 1;
      s = pointer + 1;
      pointer = s;
    }
  }
  for (let idx = p; idx < pattern.length; idx++) {
    if (pattern[idx] !== ""*"") return false;
  }
  return true;
};",Hard,"/**
 * @param {string} s
 * @param {string} p
 * @return {boolean} */
var isMatch = function(s, p) {
    const m = s.length;
    const n = p.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(false));
    dp[0][0] = true;
    for (let j = 1; j <= n; j++) {
        if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
        }
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (p[j - 1] === '*') {
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
            } else if (p[j - 1] === '?' || s[i - 1] === p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            }
        }
    }
    return dp[m][n];
};","This code implements a dynamic programming approach to wildcard pattern matching. A 2D boolean array 'dp' is used where dp[i][j] indicates if the first 'i' characters of string 's' match the first 'j' characters of pattern 'p'. Base cases include dp[0][0] as true (empty string matches empty pattern) and handling '*' at the beginning of the pattern. The code iterates through the 'dp' array, filling it based on the characters in 's' and 'p'. If 'p' has '*', dp[i][j] is true if either dp[i-1][j] (match with previous character of 's') or dp[i][j-1] (match without current character of 's') is true. If 'p' has '?' or the characters match, dp[i][j] is true if dp[i-1][j-1] is true. Finally, dp[m][n] indicates if the entire string 's' matches the entire pattern 'p'."
"var isMatch = function(s, p) {
    const m = s.length, n = p.length;
    const dp = new Array(m+1).fill().map(() => new Array(n+1).fill(false));
    dp[0][0] = true; // empty pattern matches empty string

    // initialize first row (empty string)
    for (let j = 1; j <= n; j++) {
        if (p[j-1] === '*')
        dp[0][j] = dp[0][j-2];
    }

    // fill in remaining cells
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
        if (s[i-1] === p[j-1] || p[j-1] === '.') {
            dp[i][j] = dp[i-1][j-1];
        } else if (p[j-1] === '*') {
            dp[i][j] = dp[i][j-2]; // zero occurrences
            if (s[i-1] === p[j-2] || p[j-2] === '.') {
            dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences
            }
        }
        }
    }
    return dp[m][n];
}",Hard,"/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
    const dp = Array(s.length + 1).fill(null).map(() => Array(p.length + 1).fill(false));
    dp[0][0] = true;

    for (let j = 1; j <= p.length; j++) {
        if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
        }
    }

    for (let i = 1; i <= s.length; i++) {
        for (let j = 1; j <= p.length; j++) {
            if (s[i - 1] === p[j - 1] || p[j - 1] === '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] === '*') {
                dp[i][j] = dp[i][j - 2];
                if (p[j - 2] === '.' || p[j - 2] === s[i - 1]) {
                    dp[i][j] = dp[i][j] || dp[i - 1][j];
                }
            }
        }
    }

    return dp[s.length][p.length];
};","This code implements a dynamic programming approach to solve the regular expression matching problem. A 2D boolean array 'dp' is used to store the matching results of substrings. dp[i][j] stores whether the first i characters of s match the first j characters of p. The code iterates through the dp array, filling it based on the characters in s and p. The base cases are handled: an empty pattern matches an empty string, and '*' can match zero preceding elements. The logic for matching individual characters, '.', and '*' is implemented using the appropriate conditions. Finally, dp[s.length][p.length] contains the result of matching the entire input string s with the entire pattern p."
"/**
 * @param {number[]} balloons - The input array representing the balloon values.
 * @return {number} - The maximum coins that can be collected.
 */
var maxCoins = function(balloons) {
    const n = balloons.length;

    // Pad the `balloons` array with 1 on both sides to simplify boundary cases
    balloons.push(1);
    balloons.unshift(1);

    // Create a DP table initialized with 0, with size (n+2) x (n+2)
    const dp = Array.from({ length: n + 2 }, () => Array(n + 2).fill(0));

    // Iterate backwards over all possible subarray starting points
    for (let left = n; left >= 1; left--) {
        // Iterate over all possible subarray ending points
        for (let right = left; right <= n; right++) {
            let maxCoins = -Infinity; // Store the maximum coins for subarray [left, right]

            // Try bursting each balloon `idx` in the range as the last balloon
            for (let lastBurst = left; lastBurst <= right; lastBurst++) {
                // Calculate the coins for bursting balloon `lastBurst` last
                const coins = balloons[left - 1] * balloons[lastBurst] * balloons[right + 1] +
                              dp[left][lastBurst - 1] + dp[lastBurst + 1][right];

                // Update the maximum coins for this subarray
                maxCoins = Math.max(maxCoins, coins);
            }

            // Store the maximum coins obtained for subarray [left, right] in the DP table
            dp[left][right] = maxCoins;
        }
    }

    // Return the maximum coins for bursting all balloons between 1 and n
    return dp[1][n];
};

/**
 * Time Complexity: O(n^3)
 * - We have three nested loops: one for `left`, one for `right`, and one for choosing the last balloon to burst in the range.
 * 
 * Space Complexity: O(n^2)
 * - We use a DP table of size (n+2) x (n+2) to store the results of subproblems.
 */",Hard,"/**
 * @param {number[]} nums
 * @return {number}
 */
var maxCoins = function(nums) {
    const n = nums.length;
    const vals = [1, ...nums, 1]; // Add padding 1s

    const dp = Array(n + 2).fill(0).map(() => Array(n + 2).fill(0));

    for (let len = 1; len <= n; len++) {
        for (let i = 1; i <= n - len + 1; i++) {
            const j = i + len - 1;
            for (let k = i; k <= j; k++) {
                dp[i][j] = Math.max(
                    dp[i][j],
                    dp[i][k - 1] + vals[i - 1] * vals[k] * vals[j + 1] + dp[k + 1][j]
                );
            }
        }
    }

    return dp[1][n];
};","This solution uses dynamic programming. `dp[i][j]` stores the maximum coins obtained by bursting balloons from index i to j. We iterate through different lengths of subarrays and calculate `dp[i][j]` by considering each balloon k within the range [i, j] as the last balloon to be burst. The formula `dp[i][k - 1] + vals[i - 1] * vals[k] * vals[j + 1] + dp[k + 1][j]` represents the coins obtained by bursting balloons in the left subarray, the last balloon k, and the balloons in the right subarray. Padding 1s are added to handle boundary cases."
"var solveSudoku = function(board) {
    const solve = () => {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = '1'; num <= '9'; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) return true;
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    };
    
    const isValid = (board, row, col, num) => {
        for (let i = 0; i < 9; i++) {
            if (board[row][i] === num || board[i][col] === num) return false;
        }
        let startRow = Math.floor(row / 3) * 3;
        let startCol = Math.floor(col / 3) * 3;
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (board[i][j] === num) return false;
            }
        }
        return true;
    };
    
    solve();
};",Hard,"/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
    const N = 9;

    function isValid(row, col, num) {
        for (let i = 0; i < N; i++) {
            if (board[row][i] == num || board[i][col] == num) return false;
        }

        let startRow = Math.floor(row / 3) * 3;
        let startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[startRow + i][startCol + j] == num) return false;
            }
        }
        return true;
    }

    function solve() {
        for (let row = 0; row < N; row++) {
            for (let col = 0; col < N; col++) {
                if (board[row][col] === '.') {
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(row, col, num.toString())) {
                            board[row][col] = num.toString();
                            if (solve()) return true;
                            else board[row][col] = '.'; // backtrack
                        }
                    }
                    return false; // No valid number found
                }
            }
        }
        return true; // Puzzle solved
    }

    solve();
};","This code implements a backtracking algorithm to solve Sudoku. The `isValid` function checks if placing a number at a given cell is valid according to Sudoku rules. The `solve` function recursively tries filling empty cells with numbers from 1 to 9. If a valid number is found, it proceeds to the next empty cell. If no valid number is found for a cell, it backtracks and tries a different number in the previous cell. This process continues until the entire board is filled or no solution is found."
