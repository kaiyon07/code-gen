gt_code,level,refactor_code,rationale,eslint_count_original,eslint_count_refactored,closure_count_original,closure_count_refactored,test_cases,closure_optimized_code,runtimeOriginal,runtimeOptimized,runtimeRefactored,numOptimizedCorrect,numRefactoredCorrect,total
"var createHelloWorld = function() { 
    return function() {
        return ""Hello World"";
    }
}",Easy,"/**
 * @return {Function}
 */
var createHelloWorld = function() {
    return function(...args) {
        return ""Hello World"";
    }
};","The function createHelloWorld is defined, which returns an inner function. The inner function ignores any input arguments and always returns the string ""Hello World"".  This directly addresses the problem description. No error handling is explicitly needed as the inner function is simple and cannot throw errors. The code uses modern JavaScript syntax (ES6+) and is concise and readable.",4,5,5,4,"{""functionOrClassName"": ""createHelloWorld"", ""tests"": [""createHelloWorld()()"", ""(() => {const a = createHelloWorld(); return a();})()"", ""(() => {const a = createHelloWorld; return a()();})()"", ""(() => {let f = createHelloWorld(); return f();})()"", ""(() => {let a = createHelloWorld; let b = a(); return b();})()"", ""(() => {const a = createHelloWorld(); const b = a; return b();})()"", ""(() => {const f = createHelloWorld(); return f();})()"", ""(() => {let f = createHelloWorld; return f()();})()"", ""(() => {const a = createHelloWorld(); const b = a(); return b();})()"", ""(() => {let a = createHelloWorld(); let b = a; return b()();})()"", ""(() => {let f = createHelloWorld(); let g = f(); return g();})()""]}","let createHelloWorld=function(){return function(){return""Hello World""}};
",0.3165419999999983,0.17866599999999266,0.1591669999999965,11,11,11
"var createCounter = function(init) {
  let presentCount = init;

  function increment() {
    return ++presentCount;
  }

  function decrement() {
      return --presentCount;
  }

  function reset() {
      return (presentCount = init);
  }

  return { increment, decrement, reset };
};",Easy,"/**
 * @param {integer} init
 * @return { increment: Function, decrement: Function, reset: Function }
 */
var createCounter = function(init) {
  let count = init;
  return {
    increment: function() {
      return ++count;
    },
    decrement: function() {
      return --count;
    },
    reset: function() {
      count = init;
      return count;
    }
  };
};","The code initializes a counter with the given init value. It returns an object with three methods: increment, decrement, and reset. Each method modifies the counter and returns the updated value.  The closure ensures that the counter variable is private and only accessible through the returned methods.",9,12,3,7,"{""functionOrClassName"": ""createCounter"", ""tests"": [""createCounter(5).increment()"", ""createCounter(5).decrement()"", ""createCounter(5).reset()"", ""createCounter(0).increment()"", ""createCounter(0).decrement()"", ""createCounter(0).reset()"", ""createCounter(-5).increment()"", ""createCounter(-5).decrement()"", ""createCounter(-5).reset()"", ""createCounter(100).increment()"", ""createCounter(100).decrement()"", ""createCounter(100).reset()"", ""(() => {const counter = createCounter(5); counter.increment(); counter.decrement(); return counter.reset();})()"", ""(() => {const counter = createCounter(0); counter.increment(); counter.increment(); return counter.reset();})()"", ""(() => {const counter = createCounter(-5); counter.decrement(); counter.decrement(); return counter.reset();})()"", ""(() => {const counter = createCounter(10); for (let i = 0; i < 5; i++) counter.increment(); return counter.reset();})()"", ""(() => {const counter = createCounter(20); for (let i = 0; i < 5; i++) counter.decrement(); return counter.reset();})()""]}","let createCounter=function(b){let a=b;return{h:function(){return++a},g:function(){return--a},reset:function(){return a=b}}};
",0.27333299999999383,0.47245900000000063,0.4314999999999998,4,17,17
"var map = function(arr, fn) {
    const transformedArr = [];
    arr.forEach((element, index) => {
      transformedArr[index] = fn(element, index);
    });
    return transformedArr;
  };",Easy,"/**
 * @param {number[]} arr
 * @param {Function} fn
 * @return {number[]}
 */
var map = function(arr, fn) {
  if (!Array.isArray(arr) || typeof fn !== 'function') {
    throw new Error('Invalid input: arr must be an array and fn must be a function.');
  }

  const result = [];
  for (let i = 0; i < arr.length; i++) {
    result.push(fn(arr[i], i));
  }
  return result;
};","The code iterates through the input array `arr` using a `for` loop.  For each element, it applies the provided function `fn`, passing the element and its index as arguments. The result of `fn` is then pushed into a new array `result`. Error handling is included to check if the input `arr` is an array and `fn` is a function; if not, it throws an error. This approach avoids using the built-in `Array.map` method as requested.",3,5,3,8,"{""functionOrClassName"": ""map"", ""tests"": [""map([1, 2, 3], (x) => x * 2)"", ""map([1, 2, 3], (x, i) => x + i)"", ""map([], (x) => x * 2)"", ""map([1, 2, 3], (x) => x.toString())"", ""map([1, 2, 3], (x) => x % 2 === 0 ? 'even' : 'odd')"", ""map([1, 2, 3, 4, 5], (x) => x * x)"", ""map([1.1, 2.2, 3.3], (x) => Math.floor(x))"", ""map(['a', 'b', 'c'], (x) => x.toUpperCase())"", ""map([true, false, true], (x) => !x)"", ""map([null, undefined, null], (x) => x === null ? 'null' : 'undefined')"", ""map([{a: 1}, {a: 2}], (x) => x.a)"", ""(() => {const arr = [1, 2, 3]; return map(arr, (x) => arr[x - 1] * 2);})()"", ""(() => {const fn = (x) => x * 2; return map([1, 2, 3], fn);})()""]}","let map=function(c,d){const a=[];c.forEach((e,b)=>{a[b]=d(e,b)});return a};
",0.3260839999999945,0.2481250000000017,0.5527500000000032,13,13,13
"var filter = function(arr, fn) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i)) {
      result.push(arr[i]);
    }
  }
  return result;
};",Easy,"/**
 * @param {number[]} arr
 * @param {Function} fn
 * @return {number[]}
 */
var filter = function(arr, fn) {
  if (!Array.isArray(arr) || typeof fn !== 'function') {
    throw new Error('Invalid input: arr must be an array and fn must be a function.');
  }
  const filteredArr = [];
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i)) {
      filteredArr.push(arr[i]);
    }
  }
  return filteredArr;
};","The code iterates through the input array `arr`. For each element, it calls the provided function `fn` with the element and its index. If `fn` returns a truthy value, the element is added to the `filteredArr`.  Error handling is included to check if the input `arr` is an array and `fn` is a function. This approach avoids using the built-in `filter` method as requested.",5,5,3,8,"{""functionOrClassName"": ""filter"", ""tests"": [""filter([1, 2, 3], (x) => x > 1)"", ""filter([1, 2, 3], (x) => x > 0)"", ""filter([1, 2, 3], (x, i) => i > 0)"", ""filter([1, 2, 3], (x, i) => x > i)"", ""filter([1, 2, 3, 4, 5], (x) => x % 2 === 0)"", ""filter([1, 2, 3, 4, 5], (x) => x % 2 !== 0)"", ""filter([1, 2, 3, 4, 5], (x, i) => i % 2 === 0)"", ""filter([1, 2, 3, 4, 5], (x, i) => x % 2 === 0 && i % 2 === 0)"", ""filter([], (x) => x > 0)"", ""filter([null, undefined, 0, 1, 2], (x) => x)"", ""filter([1, 2, 3], (x) => {let remainder = x%3; return remainder === 0;})"", ""filter([1, 2, 3, 4, 5, 6], (x) => {let remainder = x%3; return remainder === 0;})""]}","let filter=function(b,d){const c=[];for(let a=0;a<b.length;a++)d(b[a],a)&&c.push(b[a]);return c};
",0.24908299999999883,0.21016600000000096,0.3480419999999924,12,12,12
"/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function(nums, fn, init) {
  let val = init;
  for (let i = 0; i < nums.length; i++) {
    val = fn(val, nums[i]);
  }
  return val;
};",Easy,"/**
 * @param {number[]} nums
 * @param {Function} fn
 * @param {number} init
 * @return {number}
 */
var reduce = function(nums, fn, init) {
  if (nums.length === 0) {
    return init;
  }

  let val = init;
  for (let i = 0; i < nums.length; i++) {
    val = fn(val, nums[i]);
  }
  return val;
};","The code iterates through the input array `nums`. In each iteration, it applies the provided function `fn` to the current accumulated value `val` and the current array element. The result of the function call becomes the new accumulated value. If the array is empty, it returns the initial value `init`.  This approach avoids using the built-in `Array.reduce` method as requested.",5,6,6,6,"{""functionOrClassName"": ""reduce"", ""tests"": [""reduce([1,2,3,4], (a,b) => a + b, 0)"", ""reduce([1,2,3,4], (a,b) => a * b, 1)"", ""reduce([1,2,3,4], (a,b) => a - b, 0)"", ""reduce([], (a,b) => a + b, 0)"", ""reduce([5], (a,b) => 2 * a + b, 2)"", ""reduce([1,2,3,4], (a,b) => Math.max(a,b), -Infinity)"", ""reduce([1,2,3,4], (a,b) => Math.min(a,b), Infinity)"", ""reduce([1,2,3,4,5,6,7,8,9,10], (a,b) => a + b, 100)"", ""reduce([1,2,3,4], (a,b) => a.toString() + b.toString(), \""\"")"", ""reduce([1,2,3,4], (a,b) => a + b, 5)"", ""reduce([1,2,3,4], (a,b) => {if (a > b) {return a;} else {return b;}}, 0)""]}","let reduce=function(c,d,a){for(let b=0;b<c.length;b++)a=d(a,c[b]);return a};
",0.23891600000000324,0.19350000000000023,0.18829099999999244,11,11,11
"/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var timeLimit = function(fn, t) {
  return async function(...args) {
    return new Promise((delayresolve, reject) => {
      const timeoutId = setTimeout(() => {
        clearTimeout(timeoutId);
        reject(""Time Limit Exceeded"");
      }, t);

      fn(...args)
        .then((result) => {
          clearTimeout(timeoutId);
          delayresolve(result);
        })
        .catch((error) => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  };
};

/**
 * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);
 * limited(150).catch(console.log) // ""Time Limit Exceeded"" at t=100ms
 */",Medium,"/**
 * @param {Function} fn
 * @param {number} t
 * @return {Function}
 */
var timeLimit = function(fn, t) {
    return async function(...args) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(""Time Limit Exceeded"");
            }, t);
            fn(...args).then((result) => {
                clearTimeout(timeoutId);
                resolve(result);
            }).catch((error) => {
                clearTimeout(timeoutId);
                reject(error);
            });
        });
    };
};","The solution uses Promise.race to handle the timeout.  A Promise is created that resolves with the result of fn if it completes within the time limit t.  If the timeout is reached first, the Promise rejects with ""Time Limit Exceeded"".  Error handling is included to catch any errors thrown by fn.",12,10,4,4,"{""functionOrClassName"": ""timeLimit"", ""tests"": [""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); return limited(50);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); return limited(150).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100); return limited(100).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, 0)), 100); return limited(50);})()"", ""(() => {const limited = timeLimit((t) => new Promise((res, rej) => setTimeout(() => rej('Error'), t)), 100); return limited(50).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise((res, rej) => setTimeout(() => rej('Error'), t)), 100); return limited(150).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => {throw 'Error'}, 100); return limited(50).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 0); return limited(50).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 1000); return limited(50);})()"", ""(() => {const limited = timeLimit(async (t) => {await new Promise(res => setTimeout(res, t)); return t;}, 100); return limited(50);})()"", ""(() => {const limited = timeLimit(async (t) => {await new Promise(res => setTimeout(res, t)); return t;}, 100); return limited(150).catch(err => err);})()"", ""(() => {const limited = timeLimit(async (t) => {await new Promise((res, rej) => setTimeout(() => rej('Error'), t)); return t;}, 100); return limited(50).catch(err => err);})()"", ""(() => {const limited = timeLimit(async (t) => {await new Promise((res, rej) => setTimeout(() => rej('Error'), t)); return t;}, 100); return limited(150).catch(err => err);})()"", ""(() => {const limited = timeLimit((t) => new Promise(res => setTimeout(() => res(t), t)), 100); return limited(50);})()""]}","let timeLimit=function(d,e){return async function(...f){return new Promise((g,c)=>{const a=setTimeout(()=>{clearTimeout(a);c(""Time Limit Exceeded"")},e);d(...f).then(b=>{clearTimeout(a);g(b)}).catch(b=>{clearTimeout(a);c(b)})})}};
",1.492750000000001,0.5196670000000125,0.5098330000000004,0,0,14
"const TimeLimitedCache = function() {
    this.cache = new Map();  // Using Map so we don't need a size variable
};

TimeLimitedCache.prototype.set = function(key, value, duration) {
    let found = this.cache.has(key);
    if (found) clearTimeout(this.cache.get(key).ref);  // Cancel previous timeout
    this.cache.set(key, {
        value,  // Equivalent to `value: value`
        ref: setTimeout(() => this.cache.delete(key), duration)
    });
    return found;
};

TimeLimitedCache.prototype.get = function(key) {
    return this.cache.has(key) ? this.cache.get(key).value : -1;
};

TimeLimitedCache.prototype.count = function() {
    return this.cache.size;
};",Medium,"var TimeLimitedCache = function() {
    this.cache = new Map();
};

/** 
 * @param {number} key
 * @param {number} value
 * @param {number} duration time until expiration in ms
 * @return {boolean} if un-expired key already existed
 */
TimeLimitedCache.prototype.set = function(key, value, duration) {
    const now = Date.now();
    const expirationTime = now + duration;
    const existingEntry = this.cache.get(key);
    if (existingEntry && existingEntry.expirationTime > now) {
        this.cache.set(key, { value, expirationTime });
        return true; // Key already existed
    } else {
        this.cache.set(key, { value, expirationTime });
        return false; // Key did not exist
    }
};

/** 
 * @param {number} key
 * @return {number} value associated with key
 */
TimeLimitedCache.prototype.get = function(key) {
    const now = Date.now();
    const entry = this.cache.get(key);
    if (entry && entry.expirationTime > now) {
        return entry.value;
    } else {
        return -1;
    }
};

/** 
 * @return {number} count of non-expired keys
 */
TimeLimitedCache.prototype.count = function() {
    const now = Date.now();
    let count = 0;
    for (const [key, entry] of this.cache) {
        if (entry.expirationTime > now) {
            count++;
        }
    }
    return count;
};","The TimeLimitedCache class uses a Map to store key-value pairs along with their expiration times.  The set method updates or adds entries, returning a boolean indicating pre-existence. The get method retrieves values, returning -1 if the key is expired or doesn't exist. The count method iterates through the map, counting only non-expired entries.  Date.now() provides the current time for expiration checks. Error handling is implicit through the return values of get and the conditional logic within set and count.",14,17,6,4,"{""functionOrClassName"": ""TimeLimitedCache"", ""tests"": [""(() => {const cache = new TimeLimitedCache(); return cache.set(1, 1, 1000);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); return cache.get(1);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); return cache.count();})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(1, 2, 1000); return cache.get(1);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); setTimeout(() => { return cache.get(1); }, 2000);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(2, 2, 2000); return cache.count();})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(2, 2, 2000); cache.set(1, 10, 1000); return cache.get(1);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); return cache.get(2);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 0); return cache.get(1);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(2, 2, 2000); cache.set(3, 3, 3000); return cache.count();})()"", ""(() => {const cache = new TimeLimitedCache(); return cache.get(1);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(1, 1, 1000); return cache.count();})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); setTimeout(() => { return cache.count(); }, 2000);})()"", ""(() => {const cache = new TimeLimitedCache(); cache.set(1, 1, 1000); cache.set(2, 2, 1000); setTimeout(() => { return cache.count(); }, 2000);})()""]}","function b(){this.cache=new Map}b.prototype.set=function(a,d,e){let c=this.cache.has(a);c&&clearTimeout(this.cache.get(a).g);this.cache.set(a,{value:d,g:setTimeout(()=>this.cache.delete(a),e)});return c};b.prototype.get=function(a){return this.cache.has(a)?this.cache.get(a).value:-1};b.prototype.count=function(){return this.cache.size};let TimeLimitedCache=b;
",1.8394579999999934,0.3365000000000009,0.6388749999999987,14,13,14
"var debounce = function(fn, t) {
    let id;
        return function (...args) {
                clearTimeout(id);
                id = setTimeout(() => fn(...args), t);
        }
};",Medium,"/**
 * @param {Function} fn
 * @param {number} t milliseconds
 * @return {Function}
 */
var debounce = function(fn, t) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fn.apply(this, args);
        }, t);
    };
};","The solution uses `setTimeout` to schedule the execution of the function after `t` milliseconds.  `clearTimeout` cancels any pending timeout before scheduling a new one, ensuring that only the last call within the `t` millisecond window is executed.  The spread syntax (`...args`) allows the debounced function to accept any number of arguments and pass them to the original function.",8,9,4,4,"{""functionOrClassName"": ""debounce"", ""tests"": [""debounce(() => 1, 100)()"", ""debounce(() => {console.log(2); return 3;}, 200)()"", ""debounce((a, b) => a + b, 100)(1, 2)"", ""debounce(function(a, b) {return this.c + a + b;}, 200).bind({c: 5})(10, 20)"", ""(() => {let f = debounce((a, b) => a + b, 150); f(1, 2); return f(3, 4);})()"", ""(() => {let f = debounce((a, b) => a + b, 50); f(1, 2); return f(3, 4);})()"", ""(() => {let f = debounce((a) => a * 2, 50); return f(5);})()"", ""(() => {let f = debounce((a) => {let ret = 0; for (let i = 0; i < a; ++i) ret += i; return ret;}, 200); return f(5);})()"", ""(() => {let f = debounce((...args) => args.reduce((a, b) => a + b, 0), 100); return f(1, 2, 3, 4, 5);})()"", ""(() => {let f = debounce(async (a, b) => await Promise.resolve(a + b), 100); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => new Promise((resolve, reject) => {setTimeout(() => {resolve(a + b);}, 200);}), 100); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => a + b, 0); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => a + b, -1); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => a + b, -100); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => a + b, Infinity); return f(1, 2);})()"", ""(() => {let f = debounce((a, b) => a + b, NaN); return f(1, 2);})()""]}","let debounce=function(b,c){let a;return function(...d){clearTimeout(a);a=setTimeout(()=>b(...d),c)}};
",-1,-1,-1,-1,-1,-1
"var promiseAll = async function(functions) {
    return new Promise((resolve, reject) => {
        let results = [];
        functions.forEach(fn => {
            fn()
            .then(val => results.push(val))
            .catch(reason => reject(reason));
        });
        resolve(results);
    })};

var promiseAll = async function(functions) {
    return new Promise((resolve,reject)=>{
        if(functions.length === 0) {
            resolve([]);
            return;
        }
        const arr=new Array(functions.length);
        arr.fill(null);
        let count=0
        functions.forEach(async(fn,i)=>{
            try{
                arr[i]=await fn()
                count++
            
                if(count===functions.length){
                    resolve(arr);
                }
            }
            catch(e){
                reject(e);
            }
        
        });
    });
};",Medium,"/**
 * @param {Array<Function>} functions
 * @return {Promise<any>}
 */
var promiseAll = function(functions) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(functions) || functions.length === 0) {
      resolve([]);
      return;
    }

    const results = new Array(functions.length);
    let completedCount = 0;
    let rejected = false;

    functions.forEach((func, index) => {
      func().then((result) => {
        results[index] = result;
        completedCount++;
        if (completedCount === functions.length && !rejected) {
          resolve(results);
        }
      }).catch((error) => {
        if (!rejected) {
          rejected = true;
          reject(error);
        }
      });
    });
  });
};","The solution iterates through the array of asynchronous functions. Each function is executed, and its promise is handled using .then and .catch.  The results are stored in a results array. A completedCount variable tracks the number of completed promises. If all promises resolve, the results array is resolved. If any promise rejects, the error is immediately rejected using reject, preventing further execution.  Error handling ensures that only the first rejection is propagated.",14,6,11,7,"{""functionOrClassName"": ""promiseAll"", ""tests"": [""promiseAll([])"", ""promiseAll([async () => 1])"", ""promiseAll([async () => 1, async () => 2, async () => 3])"", ""promiseAll([async () => Promise.resolve(1), async () => Promise.resolve(2)])"", ""promiseAll([async () => Promise.reject('Error')])"", ""promiseAll([async () => 1, async () => Promise.reject('Error'), async () => 3])"", ""promiseAll([async () => {throw new Error('Error')}])"", ""promiseAll([async () => 1, async () => {throw new Error('Error')}, async () => 3])"", ""promiseAll([async () => new Promise(resolve => setTimeout(() => resolve(1), 100)), async () => 2])"", ""promiseAll([async () => new Promise(resolve => setTimeout(() => resolve(1), 100)), async () => new Promise((resolve, reject) => setTimeout(() => reject('Error'), 50))])"", ""promiseAll([async () => Promise.resolve(1), async () => Promise.resolve(2), async () => Promise.resolve(3), async () => Promise.resolve(4), async () => Promise.resolve(5)])"", ""promiseAll([async () => 1, async () => 2, async () => 3, async () => 4, async () => 5, async () => Promise.reject('Error')])"", ""promiseAll([async () => 'a', async () => 'b', async () => 'c'])"", ""promiseAll([async () => { const obj = { key: 'value' }; return obj; }])""]}",,1.1179160000000081,0.36350000000000193,0.7736249999999956,0,0,14
"class EventEmitter {
  constructor() {
    this.events = new Map();
  }

  subscribe(event, cb) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    const listeners = this.events.get(event);
    listeners.push(cb);

    return {
      unsubscribe: () => {
        const index = listeners.indexOf(cb);
        if (index !== -1) {
          listeners.splice(index, 1);
        }
      }
    };
  }

  emit(event, args = []) {
    if (!this.events.has(event)) {
      return [];
    }

    const listeners = this.events.get(event);
    const results = [];

    for (const listener of listeners) {
      results.push(listener(...args));
    }

    return results;
  }
}",Medium,"class EventEmitter {
    constructor() {
        this.events = {};
    }

    /**
     * @param {string} eventName
     * @param {Function} callback
     * @return {Object}
     */
    subscribe(eventName, callback) {
        if (!this.events[eventName]) {
            this.events[eventName] = [];
        }
        this.events[eventName].push(callback);
        const unsubscribe = () => {
            this.events[eventName] = this.events[eventName].filter((cb) => cb !== callback);
        };
        return { unsubscribe };
    }

    /**
     * @param {string} eventName
     * @param {Array} args
     * @return {Array}
     */
    emit(eventName, args = []) {
        if (!this.events[eventName]) {
            return [];
        }
        return this.events[eventName].map((callback) => callback(...args));
    }
}","The EventEmitter class uses an object to store event listeners.  The subscribe method adds a callback to the event's listener array and returns an unsubscribe function. The emit method iterates through the listeners and executes them with the provided arguments, returning an array of results. Error handling is implicit; if an event doesn't exist, an empty array is returned.  The code uses modern JS syntax (ES6+) and follows best practices for readability and organization.",4,1,3,7,"{""functionOrClassName"": ""EventEmitter"", ""tests"": [""new EventEmitter()"", ""(() => {const emitter = new EventEmitter(); return emitter.subscribe('event1', () => {});})()"", ""(() => {const emitter = new EventEmitter(); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); emitter.subscribe('event1', () => {}); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); emitter.subscribe('event1', (a, b) => a + b); return emitter.emit('event1', [1, 2]);})()"", ""(() => {const emitter = new EventEmitter(); const sub1 = emitter.subscribe('event1', () => 1); const sub2 = emitter.subscribe('event1', () => 2); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); const sub = emitter.subscribe('event1', () => {}); sub.unsubscribe(); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); const sub1 = emitter.subscribe('event1', () => 1); const sub2 = emitter.subscribe('event1', () => 2); sub1.unsubscribe(); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); emitter.subscribe('event1', () => {}); return emitter.emit('event2');})()"", ""(() => {const emitter = new EventEmitter(); const sub = emitter.subscribe('event1', () => {}); sub.unsubscribe(); sub.unsubscribe(); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); const sub = emitter.subscribe('event1', () => {throw new Error('test error');}); return emitter.emit('event1');})()"", ""(() => {const emitter = new EventEmitter(); emitter.subscribe('event1', (a) => a); emitter.subscribe('event2', (a, b) => a + b); return emitter.emit('event1', [1]);})()"", ""(() => {const emitter = new EventEmitter(); emitter.subscribe('event1', (a) => a); emitter.subscribe('event2', (a, b) => a + b); return emitter.emit('event2', [1, 2]);})()""]}","class a{}let EventEmitter=a;
",0.5282499999999999,0.3595420000000047,0.3629580000000061,1,11,13
"class Calculator {
  constructor(value) {
    this.result = value;
  }
  add(value) {
    this.result += value;
    return this;
  }

  subtract(value) {
    this.result -= value;
    return this;
  }

  multiply(value) {
    this.result *= value;
    return this;
  }

  divide(value) {
    if (value === 0) {
      throw new Error('Division by zero is not allowed');
    }
    this.result /= value;
    return this;
  }

  power(value) {
    this.result = Math.pow(this.result, value);
    return this;
  }

  getResult() {
    return this.result;
  }
}",Medium,"class Calculator {
    /** 
     * @param {number} value
     */
    constructor(value) {
        this.result = value;
    }
    
    /** 
     * @param {number} value
     * @return {Calculator}
     */
    add(value) {
        this.result += value;
        return this;
    }
    
    /** 
     * @param {number} value
     * @return {Calculator}
     */
    subtract(value) {
        this.result -= value;
        return this;
    }
    
    /** 
     * @param {number} value
     * @return {Calculator}
     */  
    multiply(value) {
        this.result *= value;
        return this;
    }
    
    /** 
     * @param {number} value
     * @return {Calculator}
     */
    divide(value) {
        if (value === 0) {
            throw new Error(""Division by zero is not allowed"");
        }
        this.result /= value;
        return this;
    }
    
    /** 
     * @param {number} value
     * @return {Calculator}
     */
    power(value) {
        this.result = Math.pow(this.result, value);
        return this;
    }
    
    /** 
     * @return {number}
     */
    getResult() {
        return this.result;
    }
}",The code implements the Calculator class with methods for basic arithmetic operations and exponentiation.  Method chaining is supported by returning 'this' in each method. Error handling is included for division by zero. The constructor initializes the result. The getResult method returns the final result.,3,3,8,6,"{""functionOrClassName"": ""Calculator"", ""tests"": [""new Calculator(5).add(3).getResult()"", ""new Calculator(10).subtract(2).getResult()"", ""new Calculator(2).multiply(4).getResult()"", ""new Calculator(10).divide(2).getResult()"", ""new Calculator(2).power(3).getResult()"", ""new Calculator(0).add(5).getResult()"", ""new Calculator(100).subtract(50).getResult()"", ""new Calculator(5).multiply(0).getResult()"", ""new Calculator(1).divide(1).getResult()"", ""new Calculator(2).power(0).getResult()"", ""new Calculator(5).add(3).subtract(2).getResult()"", ""new Calculator(2).multiply(3).divide(2).getResult()"", ""new Calculator(2).power(2).add(2).getResult()"", ""new Calculator(10).divide(2).multiply(3).getResult()"", ""(() => { let calc = new Calculator(5); calc.add(2); calc.multiply(3); return calc.getResult(); })()"", ""(() => { let calc = new Calculator(10); calc.subtract(5); calc.divide(2); return calc.getResult(); })()"", ""(() => { let calc = new Calculator(2); calc.power(3); calc.add(1); return calc.getResult(); })()"", ""(() => { let calc = new Calculator(5); return calc.add(2.5).getResult(); })()"", ""(() => { let calc = new Calculator(10); return calc.subtract(-5).getResult(); })()"", ""(() => { let calc = new Calculator(2); return calc.multiply(3.5).getResult(); })()""]}","class a{add(){return this}}let Calculator=a;
",0.3111249999999899,0.7017499999999899,0.5630839999999893,0,20,20
"/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */

class ListNode {
  constructor(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
  }
}

function arrayToList(array) {
    if (array.length === 0) return null;

    let head = new ListNode(array[0]);
    let current = head;

    for (let i = 1; i < array.length; i++) {
        current.next = new ListNode(array[i]);
        current = current.next;
    }

    return head;
}

var mergeKLists = function (lists) {
    let nums = []

    for (let i = 0; i < lists.length; i++) {
        let current = lists[i]
        while (current !== null) {
            nums.push(current.val)
            current = current.next
        }
    }

    return arrayToList(nums.sort((a, b) => a - b))
};",Medium,"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  if (!lists || lists.length === 0) return null;

  while (lists.length > 1) {
    let mergedLists = [];
    for (let i = 0; i < lists.length; i += 2) {
      let l1 = lists[i];
      let l2 = i + 1 < lists.length ? lists[i + 1] : null;
      mergedLists.push(mergeTwoLists(l1, l2));
    }
    lists = mergedLists;
  }
  return lists[0];
};

var mergeTwoLists = function(l1, l2) {
  let dummy = new ListNode();
  let tail = dummy;

  while (l1 && l2) {
    if (l1.val < l2.val) {
      tail.next = l1;
      l1 = l1.next;
    } else {
      tail.next = l2;
      l2 = l2.next;
    }
    tail = tail.next;
  }

  tail.next = l1 || l2;
  return dummy.next;
};","The solution uses a divide and conquer approach.  It repeatedly merges pairs of linked lists until only one remains. The `mergeTwoLists` helper function efficiently merges two sorted linked lists. The main function handles edge cases (empty input) and iteratively merges lists until a single sorted list is obtained. This approach has a time complexity of O(N log k), where N is the total number of nodes and k is the number of linked lists. The space complexity is O(1) excluding the output list.",22,27,16,10,"{""functionOrClassName"": ""mergeKLists"", ""tests"": [""mergeKLists([])"",""mergeKLists([arrayToList([1,4,5]),arrayToList([1,3,4]),arrayToList([2,6])])"", ""mergeKLists([arrayToList([1, 2, 3])])"", ""mergeKLists([null])"", ""mergeKLists([arrayToList([])])"", ""mergeKLists([arrayToList([1])])"", ""mergeKLists([arrayToList([1, 2, 3]), arrayToList([4, 5, 6]), arrayToList([7, 8, 9])])"", ""mergeKLists([arrayToList([1, 3, 5]), arrayToList([2, 4, 6]), arrayToList([0, 7, 8])])"", ""mergeKLists([arrayToList([1, 1, 1]), arrayToList([1, 1, 1]), arrayToList([1, 1, 1])])"", ""mergeKLists([arrayToList([-1, 0, 1]), arrayToList([-2, -1, 0]), arrayToList([0, 1, 2])])"", ""mergeKLists([arrayToList([5, 4, 3, 2, 1]), arrayToList([5, 4, 3, 2, 1]), arrayToList([5, 4, 3, 2, 1])])"", ""mergeKLists([arrayToList([1, 2, 3]), null, arrayToList([4, 5, 6])])"", ""mergeKLists([arrayToList([1, 2, 3]), arrayToList([]), arrayToList([4, 5, 6])])"", ""mergeKLists([arrayToList([1]), arrayToList([2]), arrayToList([3]), arrayToList([4]), arrayToList([5]), arrayToList([6]), arrayToList([7]), arrayToList([8]), arrayToList([9]), arrayToList([10])])""]}","class e{constructor(a){this.g=void 0===a?0:a;this.next=null}}function f(a){if(0===a.length)return null;let d=new e(a[0]),c=d;for(let b=1;b<a.length;b++)c.next=new e(a[b]),c=c.next;return d}let mergeKLists=function(a){let d=[];for(let c=0;c<a.length;c++){let b=a[c];for(;null!==b;)d.push(b.g),b=b.next}return f(d.sort((c,b)=>c-b))};
",0.3132090000000005,0.47212499999999125,0.2360829999999936,2,2,14
"/**
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function(word1, word2) {
 let result = '';
  for (let i = 0; i < Math.max(word1.length, word2.length); i++) {
    if (i < word1.length) result += word1[i];
    if (i < word2.length) result += word2[i];
  }
  return result;
};",Easy,"/**
 * @param {string} word1
 * @param {string} word2
 * @return {string}
 */
var mergeAlternately = function(word1, word2) {
  let merged = '';
  let i = 0, j = 0;

  while (i < word1.length || j < word2.length) {
    if (i < word1.length) {
      merged += word1[i];
      i++;
    }
    if (j < word2.length) {
      merged += word2[j];
      j++;
    }
  }

  return merged;
};",The function `mergeAlternately` efficiently merges two strings by iterating through them using pointers `i` and `j`. It appends characters from `word1` and `word2` alternately to the `merged` string until one string is exhausted. The remaining characters from the longer string are then appended to complete the merged string.  This approach avoids unnecessary array manipulations and ensures optimal performance.,7,8,2,2,"{""functionOrClassName"": ""mergeAlternately"", ""tests"": [""mergeAlternately(\""abc\"", \""pqr\"")"", ""mergeAlternately(\""ab\"", \""pqrs\"")"", ""mergeAlternately(\""abcd\"", \""pq\"")"", ""mergeAlternately(\""\"", \""\"")"", ""mergeAlternately(\""a\"", \""\"")"", ""mergeAlternately(\""\"", \""b\"")"", ""mergeAlternately(\""a\"", \""bc\"")"", ""mergeAlternately(\""abc\"", \""b\"")"", ""mergeAlternately(\""12345\"", \""67890\"")"", ""mergeAlternately(\""1\"", \""234567890\"")"", ""mergeAlternately(\""1234567890\"", \""1\"")"", ""mergeAlternately(\""11111\"", \""22222\"")"", ""mergeAlternately(\""123\"", \""456\"")"", ""mergeAlternately(\""11\"", \""2\"")"", ""mergeAlternately(\""1\"", \""22\"")""]}","let mergeAlternately=function(b,c){let d="""";for(let a=0;a<Math.max(b.length,c.length);a++)a<b.length&&(d+=b[a]),a<c.length&&(d+=c[a]);return d};
",0.20349999999999113,0.14920899999999904,0.3519589999999937,15,15,15
"var gcdOfStrings = function (str1, str2) {
    // handle the base case
    if (str1 + str2 !== str2 + str1) return '';
    let a = str1.length
    let b = str2.length

    // loop (divide) until you find the 
    // highest common factor (length of string) 
    // like we did in maths
    while (b) {
        let temp = b
        b = a % b
        a = temp
    }
    return str1.substring(0, a)
};",Easy,"/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
var gcdOfStrings = function(str1, str2) {
  //Error Handling for invalid inputs
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new Error('Inputs must be strings.');
  }
  if (str1.length === 0 || str2.length === 0) {
    return '';
  }

  //Find the greatest common divisor of lengths
  function gcd(a, b) {
    if (b === 0) {
      return a;
    }
    return gcd(b, a % b);
  }
  const commonLength = gcd(str1.length, str2.length);

  //Extract the potential gcd string
  const potentialGCD = str1.substring(0, commonLength);

  //Check if it divides both strings
  if (str1.length % commonLength === 0 && str2.length % commonLength === 0) {
    let str1Check = '';
    for (let i = 0; i < str1.length / commonLength; i++) {
      str1Check += potentialGCD;
    }
    let str2Check = '';
    for (let i = 0; i < str2.length / commonLength; i++) {
      str2Check += potentialGCD;
    }
    if (str1Check === str1 && str2Check === str2) {
      return potentialGCD;
    }
  }
  return '';
};","The function first handles error cases where inputs are not strings or are empty.  Then, it uses the Euclidean algorithm (gcd function) to find the greatest common divisor of the lengths of the input strings. This length represents the potential length of the greatest common divisor string. A substring of this length is extracted from str1. The function then checks if this substring, when repeated, forms both str1 and str2. If it does, the substring is returned; otherwise, an empty string is returned, indicating no common divisor string.",13,19,9,2,"{""functionOrClassName"": ""gcdOfStrings"", ""tests"": [""gcdOfStrings(\""ABCABC\"", \""ABC\"")"", ""gcdOfStrings(\""ABABAB\"", \""ABAB\"")"", ""gcdOfStrings(\""LEET\"", \""CODE\"")"", ""gcdOfStrings(\""ABCDEF\"", \""ABC\"")"", ""gcdOfStrings(\""TAU\"", \""TAU\"")"", ""gcdOfStrings(\""AAAAAAAAA\"", \""AA\"")"", ""gcdOfStrings(\""ababab\"", \""abab\"")"", ""gcdOfStrings(\""NLNLNLNLNL\"", \""NL\"")"", ""gcdOfStrings(\""OBC\"", \""OBC\"")"", ""gcdOfStrings(\""ABC\"", \""ABCABC\"")"", ""gcdOfStrings(\""A\"", \""B\"")"", ""gcdOfStrings(\""AAA\"", \""AA\"")""]}","let gcdOfStrings=function(b,a){if(b+a!==a+b)return"""";let c=b.length;for(a=a.length;a;){let d=a;a=c%a;c=d}return b.substring(0,c)};
",0.1532499999999999,0.11574999999999136,0.4815420000000046,12,12,12
"var reverseWords = function(s) {
    let words = s.split(' ');
    let res = [];

    for (let i = words.length - 1; i >= 0; i--) {
        if (words[i]) {
            res.push(words[i]);
        }
    }

    return res.join(' ');
};",Medium,"/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  // Remove leading and trailing spaces
  s = s.trim();

  // Handle empty string
  if (s === """") {
    return """";
  }

  // Split the string into words
  const words = s.split(/\s+/);

  // Reverse the order of words
  const reversedWords = words.reverse();

  // Join the words with a single space
  return reversedWords.join("" "");
};","The function first trims leading and trailing spaces from the input string. It then handles the case of an empty string. The string is split into words using a regular expression to handle multiple spaces. The words are reversed using the reverse() method, and finally, they are joined with a single space using the join() method.  Error handling is included for empty strings. The code is concise and readable, using modern JavaScript features.",11,7,3,2,"{""functionOrClassName"": ""reverseWords"", ""tests"": [""reverseWords(\""the sky is blue\"")"", ""reverseWords(\""  hello world  \"")"", ""reverseWords(\""a good   example\"")"", ""reverseWords(\""  Bob    Loves  Alice   \"")"", ""reverseWords(\""the\"")"", ""reverseWords(\""\"")"", ""reverseWords(\""    \"")"", ""reverseWords(\"" 1\"")"", ""reverseWords(\""1 \"")"", ""reverseWords(\""This is a long sentence with multiple spaces\"")"", ""reverseWords(\""  leading and trailing spaces  \"")"", ""reverseWords(\""This is a sentence with no extra spaces\"")"", ""reverseWords(\""  This  is a  sentence with  multiple spaces between words  \"")"", ""reverseWords(\""  OneWord  \"")"", ""reverseWords(\""Two Words\"")""]}","let reverseWords=function(a){a=a.split("" "");let c=[];for(let b=a.length-1;0<=b;b--)a[b]&&c.push(a[b]);return c.join("" "")};
",0.22833300000000634,0.1511250000000075,1.063167000000007,15,15,15
"var productExceptSelf = function(nums) {
    const output = Array(nums.length).fill(1);

    let left = 1;
    for (let i = 0; i < nums.length; i++) {
        output[i] *= left;
        left *= nums[i];
    }

    let right = 1;
    for (let i = nums.length - 1; i >= 0; i--) {
        output[i] *= right;
        right *= nums[i];
    }

    return output;    
};",Medium,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  if (!nums || nums.length === 0) {
    return [];
  }

  const n = nums.length;
  const result = new Array(n).fill(1);

  // Calculate prefix products
  let prefixProduct = 1;
  for (let i = 0; i < n; i++) {
    result[i] = prefixProduct;
    prefixProduct *= nums[i];
  }

  // Calculate suffix products and multiply with prefix products
  let suffixProduct = 1;
  for (let i = n - 1; i >= 0; i--) {
    result[i] *= suffixProduct;
    suffixProduct *= nums[i];
  }

  return result;
};","The solution utilizes two passes through the input array `nums`. The first pass calculates the prefix product, storing it in the `result` array. The second pass calculates the suffix product and multiplies it with the corresponding prefix product in the `result` array. This approach avoids division and achieves O(n) time complexity.  Error handling is included to manage empty or null input.",11,15,3,8,"{""functionOrClassName"": ""productExceptSelf"", ""tests"": [""productExceptSelf([1,2,3,4])"", ""productExceptSelf([0,0])"", ""productExceptSelf([1,0])"", ""productExceptSelf([0,1])"", ""productExceptSelf([1,1])"", ""productExceptSelf([-1,1])"", ""productExceptSelf([1,-1])"", ""productExceptSelf([-1,-1])"", ""productExceptSelf([1,2,3,4,5])"", ""productExceptSelf([5,4,3,2,1])"", ""productExceptSelf([1,2,0,4,5])"", ""productExceptSelf([1,2,3,0,5])"", ""productExceptSelf([0,2,3,4,5])"", ""productExceptSelf([1,0,0,0,0])"", ""productExceptSelf([0,1,0,0,0])"", ""productExceptSelf([0,0,1,0,0])"", ""productExceptSelf([0,0,0,1,0])"", ""productExceptSelf([0,0,0,0,1])""]}","let productExceptSelf=function(b){const c=Array(b.length).fill(1);var d=1;for(var a=0;a<b.length;a++)c[a]*=d,d*=b[a];d=1;for(a=b.length-1;0<=a;a--)c[a]*=d,d*=b[a];return c};
",0.2254999999999967,0.4075419999999923,0.19983399999999563,18,18,18
"/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
    let write = 0;
    let read = 0;

    while (read < chars.length) {
        let char = chars[read];
        let count = 0;

        // Count the number of consecutive characters
        while (read < chars.length && chars[read] === char) {
            count++;
            read++;
        }
        chars[write] = char;
        write++;
        if (count > 1) {
            for (let digit of String(count)) {
                chars[write] = digit;
                write++;
            }
        }
    }

    return write;
};",Medium,"/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
  if (!chars || chars.length === 0) {
    return 0; // Handle empty input
  }

  let index = 0;
  let count = 1;
  for (let i = 0; i < chars.length; i++) {
    if (i + 1 < chars.length && chars[i] === chars[i + 1]) {
      count++;
    } else {
      chars[index++] = chars[i];
      if (count > 1) {
        const countStr = String(count);
        for (let j = 0; j < countStr.length; j++) {
          chars[index++] = countStr[j];
        }
      }
      count = 1;
    }
  }
  return index;
};","The code iterates through the input array `chars`. It keeps track of consecutive repeating characters using `count`. If a character is different from the next one or it's the last character, it writes the character to the `chars` array at the `index` position. If the `count` is greater than 1, it converts the count to a string and writes each digit to the array. The function returns the new length of the compressed array.",13,19,5,5,"{""functionOrClassName"": ""compress"", ""tests"": [""compress([\""a\"",\""a\"",\""b\"",\""b\"",\""c\"",\""c\"",\""c\""])"", ""compress([\""a\""])"", ""compress([\""a\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\""])"", ""compress([\""a\"",\""a\"",\""a\"",\""b\"",\""b\"",\""a\"",\""a\""])"", ""compress([])"", ""compress([\""a\"",\""a\"",\""b\"",\""c\""])"", ""compress([\""a\"",\""b\"",\""c\""])"", ""compress([\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\""])"", ""compress([\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""b\""])"", ""compress([\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""a\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""b\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\"",\""c\""])""]}","let compress=function(a){let b=0,c=0;for(;c<a.length;){let e=a[c],d=0;for(;c<a.length&&a[c]===e;)d++,c++;a[b]=e;b++;if(1<d)for(let f of String(d))a[b]=f,b++}return b};
",0.20579100000000494,0.14512500000000728,0.4581660000000056,10,10,10
"/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var longestOnes = function(nums, k) {
    let left = 0
    let max_length = 0
    let zero_count = 0
    for (let right = 0; right < nums.length; right++) {
        if(nums[right] == 0){
            zero_count += 1
        }
        while(zero_count > k) {
            if(nums[left] == 0) {
                zero_count -= 1
            }
            left++
        }
        // Calculate the length of the current valid window 
        // and update max_length
        max_length = Math.max(max_length, right- left + 1)
    }
    return max_length
};",Medium,"/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var longestOnes = function(nums, k) {
  if (!nums || nums.length === 0 || k < 0) {
    return 0; // Handle invalid inputs
  }

  let left = 0;
  let right = 0;
  let zeroCount = 0;
  let maxLength = 0;

  while (right < nums.length) {
    if (nums[right] === 0) {
      zeroCount++;
    }

    while (zeroCount > k) {
      if (nums[left] === 0) {
        zeroCount--;
      }
      left++;
    }

    maxLength = Math.max(maxLength, right - left + 1);
    right++;
  }

  return maxLength;
};","The function uses a sliding window approach. It iterates through the array using two pointers, `left` and `right`. The `zeroCount` variable keeps track of the number of zeros within the window. If the number of zeros exceeds `k`, the left pointer moves to shrink the window until the condition is met. The `maxLength` variable stores the maximum length of the window with at most k zeros.",24,19,13,5,"{""functionOrClassName"": ""longestOnes"", ""tests"": [""longestOnes([1,1,1,0,0,0,1,1,1,1,0], 2)"", ""longestOnes([0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], 3)"", ""longestOnes([1,0,0,0,1,1,0,0,1,1], 0)"", ""longestOnes([1,1,1,1,1,1,1,1,1,1], 5)"", ""longestOnes([0,0,0,0,0], 0)"", ""longestOnes([0,0,0,0,0], 2)"", ""longestOnes([], 0)"", ""longestOnes([1], 0)"", ""longestOnes([0], 1)"", ""longestOnes([1,0,1,0,1,0,1], 4)"", ""longestOnes([1,0,1,0,1,0,1,0,1,0,1], 10)"", ""longestOnes([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], 5)""]}","let longestOnes=function(b,f){let c=0,d=0,e=0;for(let a=0;a<b.length;a++){for(0==b[a]&&(e+=1);e>f;)0==b[c]&&--e,c++;d=Math.max(d,a-c+1)}return d};
",0.17820800000001213,0.14058300000000656,0.4508330000000029,12,12,12
"/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[][]}
 */
var findDifference = function(nums1, nums2) {
    let set1 = new Set(nums1);
    let set2 = new Set(nums2);
    let uniqueToNums1 = Array.from(set1).filter(x => !set2.has(x));
    let uniqueToNums2 = Array.from(set2).filter(x => !set1.has(x));

    return [uniqueToNums1, uniqueToNums2];
};",Medium,"/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[][]}
 */
var findDifference = function(nums1, nums2) {
  const set1 = new Set(nums1);
  const set2 = new Set(nums2);
  const result = [[], []];

  for (const num of nums1) {
    if (!set2.has(num)) {
      result[0].push(num);
    }
  }

  for (const num of nums2) {
    if (!set1.has(num)) {
      result[1].push(num);
    }
  }

  return result;
};","The function `findDifference` efficiently finds the distinct integers in `nums1` not present in `nums2` and vice-versa using Sets. Sets provide constant time complexity for checking membership (`has()`), making the overall algorithm efficient. The result is stored in a 2D array, adhering to the problem's output format.",12,7,9,9,"{""functionOrClassName"": ""findDifference"", ""tests"": [""findDifference([1, 2, 3], [2, 4, 6])"", ""findDifference([1, 2, 3, 3], [2, 3, 4, 6])"", ""findDifference([1, 2, 3], [2, 4, 6, 1, 2, 3])"", ""findDifference([], [])"", ""findDifference([1, 2, 3], [])"", ""findDifference([], [4, 5, 6])"", ""findDifference([1], [1])"", ""findDifference([1, 1, 1, 2, 2, 3], [1, 2, 4, 5, 6])"", ""findDifference([1, 2, 3, 4, 5], [5, 4, 3, 2, 1])"", ""findDifference([1, 2, 3, 4, 5, 5, 5, 5], [5, 4, 3, 2, 1, 1, 1, 1])""]}","let findDifference=function(a,b){let d=new Set(a),e=new Set(b);a=Array.from(d).filter(c=>!e.has(c));b=Array.from(e).filter(c=>!d.has(c));return[a,b]};
",0.2047500000000042,0.15708300000000008,0.4524159999999995,10,10,10
"/**
 * @param {string} s
 * @return {string}
 */
var removeStars = function(s) {
let i = 0;
    let stk = [];
     while(i<s.length){
         if(s.charAt(i)===""*""){
            if(stk.length>0){
                stk.pop();
            }
         }
         else {
             stk.push(s.charAt(i))
         }
         i++;
     }
    return stk.join("""");
};",Medium,"/**
 * @param {string} s
 * @return {string} 
 */
var removeStars = function(s) {
  const stack = [];
  for (let char of s) {
    if (char === '*') {
      stack.pop();
    } else {
      stack.push(char);
    }
  }
  return stack.join('');
};","The solution uses a stack to efficiently process the string.  It iterates through the string character by character. If it encounters a star, it pops the last element from the stack (the closest non-star character to its left). Otherwise, it pushes the character onto the stack. Finally, it joins the elements in the stack to form the resulting string. This approach avoids unnecessary string manipulations and has a time complexity of O(n), where n is the length of the string.",9,5,3,2,"{""functionOrClassName"": ""removeStars"", ""tests"": [""removeStars(\""leet**cod*e\"")"", ""removeStars(\""erase*****\"")"", ""removeStars(\""\"")"", ""removeStars(\""a\"")"", ""removeStars(\""*\"")"", ""removeStars(\""**\"")"", ""removeStars(\""***\"")"", ""removeStars(\""****\"")"", ""removeStars(\""*****\"")"", ""removeStars(\""abcdef\"")"", ""removeStars(\""aabbccddeeff\"")"", ""removeStars(\""a*b*c*d*e*f\"")"", ""removeStars(\""*******\"")"", ""removeStars(\""le*et**cod*e\"")"", ""removeStars(\""erase*****\"")""]}","let removeStars=function(c){let a=0,b=[];for(;a<c.length;)""*""===c.charAt(a)?0<b.length&&b.pop():b.push(c.charAt(a)),a++;return b.join("""")};
",0.18550000000000466,0.3662909999999897,0.1652910000000105,15,15,15
"var predictPartyVictory = function(senate) {
    senate = senate.split('');
    while(senate.length) {
        var first = senate.shift();
        var len = senate.length;

        for(var i=0; i<len; i++) {
            if(first != senate[i]) {
                senate.splice(i, 1);
                senate.push(first);
                break;
            }
        }
        if(i == len) {
            return first == 'D' ? 'Dire' : 'Radiant';
        }
    }
};",Medium,"/**
 * @param {string} senate
 * @return {string}
 */
var predictPartyVictory = function(senate) {
  let senators = senate.split('');
  let banned = new Array(senators.length).fill(false);
  let radiantCount = senators.filter(s => s === 'R').length;
  let direCount = senators.length - radiantCount;

  for (let i = 0; i < senators.length; i++) {
    if (banned[i]) continue;

    let currentParty = senators[i];
    let otherParty = currentParty === 'R' ? 'D' : 'R';
    let remainingSenators = senators.filter((s, index) => !banned[index]);
    let remainingRadiant = remainingSenators.filter(s => s === 'R').length;
    let remainingDire = remainingSenators.length - remainingRadiant;

    if (remainingRadiant === 0 || remainingDire === 0) {
      return currentParty === 'R' ? 'Radiant' : 'Dire';
    }

    let targetIndex = -1;
    if (currentParty === 'R') {
      targetIndex = remainingSenators.findIndex(s => s === 'D');
    } else {
      targetIndex = remainingSenators.findIndex(s => s === 'R');
    }

    if (targetIndex !== -1) {
      banned[senators.indexOf(remainingSenators[targetIndex], i)] = true;
    }
  }

  // Should not reach here if the input is valid
  return '';
};","The function iterates through the senators. If a senator can announce victory, it returns the party. Otherwise, it bans a senator from the opposite party.  The loop continues until a victory is declared. Error handling is implicit; if the input is invalid, an empty string is returned. The solution uses a `banned` array to track disabled senators and efficiently determines the remaining senators of each party in each round.",22,38,6,4,"{""functionOrClassName"": ""predictPartyVictory"", ""tests"": [""predictPartyVictory(\""RD\"")"", ""predictPartyVictory(\""RDD\"")"", ""predictPartyVictory(\""DDRRR\"")"", ""predictPartyVictory(\""RDDR\"")"", ""predictPartyVictory(\""RDRDR\"")"", ""predictPartyVictory(\""RRRDDD\"")"", ""predictPartyVictory(\""DRRDRDR\"")"", ""predictPartyVictory(\""RRRRDDDD\"")"", ""predictPartyVictory(\""DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\"")""]}","let predictPartyVictory=function(a){for(a=a.split("""");a.length;){for(var c=a.shift(),d=a.length,b=0;b<d;b++)if(c!=a[b]){a.splice(b,1);a.push(c);break}if(b==d)return""D""==c?""Dire"":""Radiant""}};
",0.30074999999999363,0.38016700000000014,0.5477920000000012,9,2,9
"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    if(head === null)return null;
    prev = new ListNode(0);
    prev.next = head;
    slow = prev;
    fast = head;
    while(fast != null && fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    slow.next = slow.next.next;
    return prev.next;
};",Medium,"/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteMiddle = function(head) {
    if (head === null || head.next === null) {
        return null;
    }

    let slow = head;
    let fast = head;
    let prev = null;

    while (fast !== null && fast.next !== null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }

    if (prev === null) {
        return slow.next;
    } else {
        prev.next = slow.next;
        return head;
    }
};","The function `deleteMiddle` efficiently removes the middle node of a linked list. It uses two pointers, `slow` and `fast`, to traverse the list. The `fast` pointer moves twice as fast as the `slow` pointer. When `fast` reaches the end, `slow` will be at the middle node. The `prev` pointer keeps track of the node before `slow`, allowing for the removal of the middle node by updating the `next` pointer of `prev`.  The edge cases of an empty list or a list with only one node are handled appropriately.",24,7,10,6,"{""functionOrClassName"": ""deleteMiddle"", ""tests"": [""deleteMiddle(null)"", ""deleteMiddle(new ListNode(1))"", ""deleteMiddle(new ListNode(1, new ListNode(2)))"", ""deleteMiddle(new ListNode(1, new ListNode(2, new ListNode(3))))"", ""deleteMiddle(new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4)))))"", ""deleteMiddle(new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5))))))"", ""deleteMiddle(new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5, new ListNode(6)))))))"", ""deleteMiddle(new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5, new ListNode(6, new ListNode(7))))))))"", ""(() => {let a = new ListNode(1); let b = new ListNode(2); let c = new ListNode(3); a.next = b; b.next = c; return deleteMiddle(a);})()"", ""(() => {let a = new ListNode(1); let b = new ListNode(2); let c = new ListNode(3); let d = new ListNode(4); a.next = b; b.next = c; c.next = d; return deleteMiddle(a);})()""]}",,0.28804200000000435,0.18754099999999596,0.178291999999999,9,10,10
"function lowestCommonAncestor(root, p, q) {
  if (!root || root === p || root === q) return root;
  var resL = lowestCommonAncestor(root.left, p, q);
  var resR = lowestCommonAncestor(root.right, p, q);
  return (resL && resR) ? root : (resL || resR);
}",Medium,"/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (!root || root === p || root === q) return root;

    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);

    if (left && right) return root;
    return left || right;
};","The solution uses a recursive approach.  The base case is when the root is null, or when the root is either p or q. In this case, the root is returned. Otherwise, the function recursively calls itself on the left and right subtrees. If both left and right calls return a node (meaning p and q are on different sides), then the current root is the LCA. Otherwise, the LCA is either in the left or right subtree, so we return whichever is not null.",11,8,4,10,"{""functionOrClassName"": ""lowestCommonAncestor"", ""tests"": [""lowestCommonAncestor(null, null, null)"", ""lowestCommonAncestor(null, {val: 1}, null)"", ""lowestCommonAncestor({val: 1}, {val: 1}, null)"", ""lowestCommonAncestor({val: 1}, null, {val: 1})"", ""lowestCommonAncestor({val: 1, left: {val: 2}, right: {val: 3}}, {val: 1}, {val: 3})"", ""lowestCommonAncestor({val: 1, left: {val: 2}, right: {val: 3}}, {val: 2}, {val: 3})"", ""lowestCommonAncestor({val: 1, left: {val: 2}, right: {val: 3}}, {val: 2}, {val: 2})"", ""lowestCommonAncestor({val: 1, left: {val: 2, left: {val: 4}}, right: {val: 3}}, {val: 2}, {val: 4})"", ""lowestCommonAncestor({val: 1, left: {val: 2, left: {val: 4}}, right: {val: 3}}, {val: 4}, {val: 3})"", ""lowestCommonAncestor({val: 1, left: {val: 2, left: {val: 4}}, right: {val: 3, right: {val: 5}}}, {val: 4}, {val: 5})"", ""lowestCommonAncestor({val: 1, left: {val: 2, left: {val: 4, left: {val: 6}}}, right: {val: 3}}, {val: 6}, {val: 4})"", ""lowestCommonAncestor({val: 1, left: {val: 2}, right: {val: 3}}, {val: 6}, {val: 7})"", ""lowestCommonAncestor({val: 1, left: {val: 2}, right: {val: 3}}, {val: 3}, {val: 2})""]}","function c(a,b,d){if(!a||a===b||a===d)return a;var e=c(a.left,b,d);b=c(a.right,b,d);return e&&b?a:e||b}let lowestCommonAncestor=c;
",0.2224999999999966,0.1759580000000085,0.40612499999998875,13,13,13
"var findCircleNum = function (isConnected) {

    let provinces = 0;
    let visited = new Array(isConnected.length).fill(false);

    for (let i = 0; i < isConnected.length; i++) {
        if (!visited[i]) {
            provinces++;
            dfs(isConnected, visited, i);
        }
    }
    return provinces;
};

function dfs(isConnected, visited, i) {

    visited[i] = true;
    
    for (let j = 0; j < isConnected.length; j++) {
        if (isConnected[i][j] === 1 && !visited[j]) {
            dfs(isConnected, visited, j);
        }
    }
}",Medium,"/**
 * @param {number[][]} isConnected
 * @return {number}
 */
var findCircleNum = function(isConnected) {
  const n = isConnected.length;
  if (n === 0) return 0;

  const visited = new Array(n).fill(false);
  let count = 0;

  const dfs = (node) => {
    visited[node] = true;
    for (let i = 0; i < n; i++) {
      if (isConnected[node][i] === 1 && !visited[i]) {
        dfs(i);
      }
    }
  };

  for (let i = 0; i < n; i++) {
    if (!visited[i]) {
      dfs(i);
      count++;
    }
  }

  return count;
};","The solution uses Depth First Search (DFS) to traverse the graph represented by the adjacency matrix isConnected.  The visited array keeps track of visited nodes. The dfs function recursively explores all connected nodes. The outer loop iterates through all nodes, and if a node hasn't been visited, it starts a new DFS traversal, incrementing the province count. This efficiently counts the number of connected components (provinces) in the graph.",14,15,4,5,-1,-1,-1,-1,-1,-1,-1,-1
"var findPeakElement = function(nums) {
    var start = 0, end = nums.length - 1;
    while (start < end) {
        var mid = Math.floor((start + end) / 2);
        if (mid === 0) {
            return nums[0] >= nums[1] ? 0 : 1;
        }
        if (mid === end) {
            return nums[end - 1] >= nums[end - 2] ? end - 1 : end - 2;
        }

        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
            return mid;
        }
        if (nums[mid] < nums[mid - 1]) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    return start;
};",Medium,"/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    let mid = Math.floor((left + right) / 2);

    if (nums[mid] < nums[mid + 1]) {
      left = mid + 1; // Peak is in the right half
    } else {
      right = mid; // Peak is in the left half or at mid
    }
  }

  return left; // left and right converge at the peak index
};","The solution employs binary search for efficiency. It compares the middle element with its right neighbor. If the middle element is smaller, the peak must be in the right half; otherwise, it's in the left half or at the middle.  The search space is halved in each iteration, resulting in O(log n) time complexity. The loop continues until the left and right pointers converge at the index of a peak element.",27,13,5,5,"{""functionOrClassName"": ""findPeakElement"", ""tests"": [""findPeakElement([1,2,3,1])"", ""findPeakElement([1,2,1,3,5,6,4])"", ""findPeakElement([1])"", ""findPeakElement([1, 2])"", ""findPeakElement([2, 1])"", ""findPeakElement([1, 2, 3])"", ""findPeakElement([3, 2, 1])"", ""findPeakElement([1, 3, 2, 4, 3])"", ""findPeakElement([1,2,3,4,5,4,3,2,1,0])"", ""findPeakElement([0,1,2,3,4,5,4,3,2,1])"", ""findPeakElement([1,2,3,4,5])"", ""findPeakElement([5,4,3,2,1])""]}","let findPeakElement=function(a){for(var d=0,c=a.length-1;d<c;){var b=Math.floor((d+c)/2);if(0===b)return a[0]>=a[1]?0:1;if(b===c)return a[c-1]>=a[c-2]?c-1:c-2;if(a[b]>a[b+1]&&a[b]>a[b-1])return b;a[b]<a[b-1]?c=b-1:d=b+1}return d};
",0.16508299999999565,0.4092500000000001,0.12783299999999542,12,11,12
"var twoSum = function(nums, target) {
    
    let numToIndexMap = {};

    
    for (let i = 0; i < nums.length; i++) {
        
        let diff = target - nums[i];

        
        if (numToIndexMap.hasOwnProperty(diff)) {
            
            return [i, numToIndexMap[diff]];
        }

        
        numToIndexMap[nums[i]] = i;
    }

    
    return null;
};",Easy,"/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  const numMap = {}; // Create a map to store numbers and their indices

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (complement in numMap) {
      // Found the complement, return the indices
      return [numMap[complement], i];
    }
    numMap[nums[i]] = i; // Store the number and its index
  }

  // No solution found
  throw new Error('No two numbers add up to the target.');
};","The code uses a hash map (numMap) to store each number and its index. It iterates through the input array. For each number, it calculates the complement needed to reach the target. If the complement exists in the map, it means we've found the pair, and their indices are returned. If the loop completes without finding a pair, an error is thrown.",8,7,3,7,"{""functionOrClassName"": ""twoSum"", ""tests"": [""twoSum([2,7,11,15], 9)"", ""twoSum([3,2,4], 6)"", ""twoSum([3,3], 6)"", ""twoSum([1, 4, 5, 7, 9, 11], 12)"", ""twoSum([1, 4, 5, 7, 9, 11], 22)"", ""twoSum([1, 4, 5, 7, 9, 11], 2)"", ""twoSum([-1, -3, 7, 5], 4)"", ""twoSum([-1, -3, 7, 5], 12)"", ""twoSum([0, 4, 3, 0], 0)"", ""twoSum([2,5,5,11], 10)"", ""twoSum([1, 2, 3, 4, 5], 7)"", ""twoSum([1, 2, 3, 4, 5], 10)""]}","let twoSum=function(b,e){let c={};for(let a=0;a<b.length;a++){let d=e-b[a];if(c.hasOwnProperty(d))return[a,c[d]];c[b[a]]=a}return null};
",0.18666600000000244,0.14858300000000213,0.46812500000000057,12,0,12
"var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }
    
    var freq = new Array(26).fill(0);
    for (var i = 0; i < s.length; i++) {
        freq[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
        freq[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }
    
    for (var i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }
    
    return true;
};",Easy,"/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
  //Error Handling for invalid inputs
  if(typeof s !== 'string' || typeof t !== 'string'){
    throw new Error('Invalid input: Inputs must be strings');
  }
  if(s.length !== t.length){
    return false; //Anagrams must have the same length
  }

  const sCharCount = {};
  const tCharCount = {};

  for(let i = 0; i < s.length; i++){
    sCharCount[s[i]] = (sCharCount[s[i]] || 0) + 1;
    tCharCount[t[i]] = (tCharCount[t[i]] || 0) + 1;
  }

  for(let char in sCharCount){
    if(sCharCount[char] !== tCharCount[char]){
      return false;
    }
  }
  return true;
};","The function first handles invalid input types. It then checks if the lengths of the input strings are different; if they are, it returns `false` because anagrams must have the same length. Two objects `sCharCount` and `tCharCount` are used to store the character counts of strings `s` and `t` respectively. The function iterates through the strings and updates the counts in the respective objects. Finally, it iterates through the keys of `sCharCount` and compares the counts in both objects. If any character counts are different, it returns `false`; otherwise, it returns `true`.",34,15,6,2,"{""functionOrClassName"": ""isAnagram"", ""tests"": [""isAnagram(\""anagram\"", \""nagaram\"")"", ""isAnagram(\""rat\"", \""car\"")"", ""isAnagram(\""a\"", \""ab\"")"", ""isAnagram(\""ab\"", \""a\"")"", ""isAnagram(\""anagram\"", \""margana\"")"", ""isAnagram(\""listen\"", \""silent\"")"", ""isAnagram(\""triangle\"", \""integral\"")"", ""isAnagram(\""hello\"", \""world\"")"", ""isAnagram(\""aacc\"", \""caca\"")"", ""isAnagram(\""ab\"", \""ba\"")"", ""isAnagram(\""elb\"", \""bel\"")"", ""isAnagram(\""study\"", \""dusty\"")"", ""isAnagram(\""night\"", \""thing\"")"", ""isAnagram(\""inch\"", \""chin\"")"", ""isAnagram(\""act\"", \""cat\"")""]}","let isAnagram=function(c,d){if(c.length!==d.length)return!1;for(var b=Array(26).fill(0),a=0;a<c.length;a++)b[c.charCodeAt(a)-97]++,b[d.charCodeAt(a)-97]--;for(a=0;a<b.length;a++)if(0!==b[a])return!1;return!0};
",0.23058299999999576,0.44195800000001384,0.29512499999999875,15,15,15
"var romanToInt = function(s) {
    let res = 0;
    const roman = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    };

    for (let i = 0; i < s.length - 1; i++) {
        if (roman[s[i]] < roman[s[i + 1]]) {
            res -= roman[s[i]];
        } else {
            res += roman[s[i]];
        }
    }

    return res + roman[s[s.length - 1]];    
};",Easy,"/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
  const romanMap = {
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000
  };

  let result = 0;
  for (let i = 0; i < s.length; i++) {
    const currentVal = romanMap[s[i]];
    const nextVal = romanMap[s[i + 1]];

    if (nextVal && currentVal < nextVal) {
      result -= currentVal;
    } else {
      result += currentVal;
    }
  }

  return result;
};","The function `romanToInt` converts a Roman numeral string to an integer. It uses a `romanMap` to store the integer values of Roman numerals. The function iterates through the input string, comparing the value of each numeral with the next one. If the current numeral is smaller than the next, it subtracts the current value; otherwise, it adds the current value to the result.  Error handling is implicitly done through the use of the `romanMap`. If an invalid Roman numeral is provided, it will either return 0 or throw an error depending on how the map handles undefined keys.  The code is concise and readable, using modern JavaScript syntax.",11,10,3,2,"{""functionOrClassName"": ""romanToInt"", ""tests"": [""romanToInt(\""III\"")"", ""romanToInt(\""LVIII\"")"", ""romanToInt(\""MCMXCIV\"")"", ""romanToInt(\""IX\"")"", ""romanToInt(\""IV\"")"", ""romanToInt(\""XL\"")"", ""romanToInt(\""XC\"")"", ""romanToInt(\""CD\"")"", ""romanToInt(\""CM\"")"", ""romanToInt(\""MMMCMXCIX\"")"", ""romanToInt(\""I\"")"", ""romanToInt(\""V\"")"", ""romanToInt(\""X\"")"", ""romanToInt(\""L\"")"", ""romanToInt(\""C\"")"", ""romanToInt(\""D\"")"", ""romanToInt(\""M\"")""]}","let romanToInt=function(a){let d=0;const c={I:1,V:5,X:10,L:50,C:100,D:500,M:1E3};for(let b=0;b<a.length-1;b++)d=c[a[b]]<c[a[b+1]]?d-c[a[b]]:d+c[a[b]];return d+c[a[a.length-1]]};
",0.21358399999999733,0.38308400000001086,0.17133300000000418,17,17,17
"var isPalindrome = function(x) {
    if (x < 0) {
        return false;
    }

    let reverse = 0;
    let xcopy = x;

    while (x > 0) {
        reverse = (reverse * 10) + (x % 10);
        x = Math.floor(x / 10);
    }

    return reverse === xcopy;    
};",Easy,"/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
  // Handle negative numbers and numbers ending in 0
  if (x < 0 || (x !== 0 && x % 10 === 0)) {
    return false;
  }

  let revertedNumber = 0;
  let originalNumber = x;

  while (originalNumber > 0) {
    revertedNumber = revertedNumber * 10 + originalNumber % 10;
    originalNumber = Math.floor(originalNumber / 10);
  }

  return revertedNumber === x;
};","The function first handles trivial cases: negative numbers and numbers ending in 0 (except 0 itself) are not palindromes.  Then, it reverses the input number using a while loop. Finally, it compares the reversed number with the original number to determine if it's a palindrome. This approach avoids converting the number to a string, which is generally less efficient.",12,13,3,2,"{""functionOrClassName"": ""isPalindrome"", ""tests"": [""isPalindrome(121)"", ""isPalindrome(-121)"", ""isPalindrome(10)"", ""isPalindrome(12321)"", ""isPalindrome(123321)"", ""isPalindrome(1221)"", ""isPalindrome(0)"", ""isPalindrome(1)"", ""isPalindrome(9999)"", ""isPalindrome(100001)"", ""isPalindrome(1000001)"", ""isPalindrome(2147483647)"", ""isPalindrome(2147447412)"", ""isPalindrome(1234567899)""]}","let isPalindrome=function(a){if(0>a)return!1;let b=0,c=a;for(;0<a;)b=10*b+a%10,a=Math.floor(a/10);return b===c};
",0.15304100000000176,0.12845900000000654,0.41020800000001145,14,14,14
"/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var ans = [];

    for (var i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            ans.push(""FizzBuzz"");
        } else if (i % 3 === 0) {
            ans.push(""Fizz"");
        } else if (i % 5 === 0) {
            ans.push(""Buzz"");
        } else {
            ans.push(i.toString());
        }
    }

    return ans;
};",Easy,"/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
  if (typeof n !== 'number' || n <= 0 || !Number.isInteger(n)) {
    throw new Error('Invalid input: n must be a positive integer.');
  }
  const result = [];
  for (let i = 1; i <= n; i++) {
    if (i % 15 === 0) {
      result.push(""FizzBuzz"");
    } else if (i % 3 === 0) {
      result.push(""Fizz"");
    } else if (i % 5 === 0) {
      result.push(""Buzz"");
    } else {
      result.push(String(i));
    }
  }
  return result;
};","The function first validates the input to ensure it's a positive integer.  Then, it iterates from 1 to n. For each number, it checks divisibility by 15 (FizzBuzz), 3 (Fizz), and 5 (Buzz) in that order. If none of these conditions are met, the number itself (converted to a string) is added to the result array. The function returns the result array containing the FizzBuzz strings.",18,13,6,4,"{""functionOrClassName"": ""fizzBuzz"", ""tests"": [""fizzBuzz(1)"", ""fizzBuzz(2)"", ""fizzBuzz(3)"", ""fizzBuzz(5)"", ""fizzBuzz(15)"", ""fizzBuzz(0)"", ""fizzBuzz(100)"", ""fizzBuzz(30)"", ""fizzBuzz(21)"", ""fizzBuzz(50)"", ""fizzBuzz(99)"", ""fizzBuzz(1000)"", ""fizzBuzz(3000)"", ""fizzBuzz(5000)"", ""fizzBuzz(15000)"", ""fizzBuzz(1)"", ""fizzBuzz(4)"", ""fizzBuzz(7)"", ""fizzBuzz(11)"", ""fizzBuzz(13)""]}","let fizzBuzz=function(c){for(var b=[],a=1;a<=c;a++)0===a%3&&0===a%5?b.push(""FizzBuzz""):0===a%3?b.push(""Fizz""):0===a%5?b.push(""Buzz""):b.push(a.toString());return b};
",2.5342079999999925,1.629374999999996,2.305874999999986,20,19,20
"/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    const hash = {};
    let res = 0;
    let majority = 0;

    for (let n of nums) {
        hash[n] = 1 + (hash[n] || 0);
        if (hash[n] > majority) {
            res = n;
            majority = hash[n];
        }
    }

    return res;    
};",Easy,"/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
  if (!nums || nums.length === 0) {
    throw new Error('Input array cannot be null or empty.');
  }

  const numCount = {};
  for (const num of nums) {
    numCount[num] = (numCount[num] || 0) + 1;
  }

  let majorityElement = null;
  let maxCount = 0;
  for (const num in numCount) {
    if (numCount[num] > maxCount) {
      maxCount = numCount[num];
      majorityElement = parseInt(num);
    }
  }

  return majorityElement;
};","The function first checks for invalid input. Then it uses a hash map to count the occurrences of each number. Finally, it iterates through the hash map to find the number with the maximum count, which is the majority element.  The parseInt is used to convert the keys (which are strings) back to numbers. Error handling is included to manage null or empty input arrays.",8,10,5,7,"{""functionOrClassName"": ""majorityElement"", ""tests"": [""majorityElement([3,2,3])"", ""majorityElement([2,2,1,1,1,2,2])"", ""majorityElement([1])"", ""majorityElement([1, 2])"", ""majorityElement([1, 1, 2])"", ""majorityElement([1, 2, 2])"", ""majorityElement([1, 1, 2, 2, 3])"", ""majorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4])"", ""majorityElement([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10, 10])"", ""majorityElement([2, 2, 2, 2, 2, 1, 3, 4, 5, 6, 7, 8, 9, 10])"", ""majorityElement([1, 2, 3, 4, 5, 1, 1, 1, 1, 1])""]}","let majorityElement=function(e){const b={};let c=0,d=0;for(let a of e)b[a]=1+(b[a]||0),b[a]>d&&(c=a,d=b[a]);return c};
",0.1844999999999999,0.14633400000001018,0.43200000000000216,11,11,11
"
var firstUniqChar = function(s) {
    let mp = {};

    for (let a of s) {
        mp[a] = (mp[a] || 0) + 1;
    }

    for (let i = 0; i < s.length; i++) {
        if (mp[s[i]] === 1) {
            return i;
        }
    }

    return -1;
};
",Easy,"/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
  const charCount = {};
  for (let char of s) {
    charCount[char] = (charCount[char] || 0) + 1;
  }

  for (let i = 0; i < s.length; i++) {
    if (charCount[s[i]] === 1) {
      return i;
    }
  }

  return -1;
};","The function first counts the occurrences of each character in the string using a character count object. Then, it iterates through the string again. For each character, it checks its count in the character count object. If the count is 1, it means that the character is non-repeating, and its index is returned. If no non-repeating character is found after iterating through the entire string, -1 is returned.",13,11,3,2,"{""functionOrClassName"": ""firstUniqChar"", ""tests"": [""firstUniqChar(\""leetcode\"")"", ""firstUniqChar(\""loveleetcode\"")"", ""firstUniqChar(\""aabb\"")"", ""firstUniqChar(\""dddccdbba\"")"", ""firstUniqChar(\""z\"")"", ""firstUniqChar(\""aadadaad\"")"", ""firstUniqChar(\""abcabcbb\"")"", ""firstUniqChar(\""\"")"", ""firstUniqChar(\""cc\"")"", ""firstUniqChar(\""ovo\"")"", ""firstUniqChar(\""blahblah\"")""]}","let firstUniqChar=function(b){let c={};for(var a of b)c[a]=(c[a]||0)+1;for(a=0;a<b.length;a++)if(1===c[b[a]])return a;return-1};
",0.2309580000000011,0.13087500000000318,0.4287080000000003,11,11,11
"function binarySearch(nums, target) {
  let left = 0;
  let right = nums.length - 1;
  
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}",Easy,"/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return mid;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
};","The function implements a binary search algorithm. It initializes two pointers, `left` and `right`, to the start and end of the array, respectively.  The algorithm iteratively narrows down the search space by comparing the middle element with the target. If the target is found, its index is returned. If the target is greater than the middle element, the search continues in the right half; otherwise, it continues in the left half. If the target is not found after the loop completes, -1 is returned. This approach guarantees O(log n) time complexity because the search space is halved in each iteration.",8,9,2,5,"{""functionOrClassName"": ""binarySearch"", ""tests"": [""binarySearch([1, 2, 3, 4, 5], 3)"", ""binarySearch([1, 2, 3, 4, 5], 6)"", ""binarySearch([1, 2, 3, 4, 5], 1)"", ""binarySearch([1, 2, 3, 4, 5], 5)"", ""binarySearch([1, 2, 3, 4, 5], 2)"", ""binarySearch([2, 5], 2)"", ""binarySearch([2, 5], 5)"", ""binarySearch([2, 5], 3)"", ""binarySearch([2, 5], 1)"", ""binarySearch([2, 5], 6)"", ""binarySearch([], 1)"", ""binarySearch([1], 1)"", ""binarySearch([1, 5], 5)"", ""binarySearch([1, 5], 1)"", ""binarySearch([1, 3, 5, 7, 9, 11], 7)"", ""binarySearch([1, 3, 5, 7, 9, 11], 12)"", ""binarySearch([1, 3, 5, 7, 9, 11], 0)"", ""binarySearch([1, 5, 6, 8, 10], 10)"", ""binarySearch([1, 5, 6, 8, 10], 1)""]}","let binarySearch=function(b,e){let c=0,d=b.length-1;for(;c<=d;){const a=Math.floor((c+d)/2);if(b[a]===e)return a;b[a]<e?c=a+1:d=a-1}return-1};
",0.2079169999999948,0.3831249999999926,0.2577919999999949,19,0,19
"var moveZeroes = function(nums) {
    let left = 0;

    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== 0) {
            [nums[right], nums[left]] = [nums[left], nums[right]];
            left++;
        }
    }

    return nums;    
};",Easy,"/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
  //Error Handling: Check if the input is a valid array
  if (!Array.isArray(nums)) {
    throw new Error('Invalid input: nums must be an array.');
  }

  let nonZeroIndex = 0; //Index to track the position for the next non-zero element

  //Iterate through the array
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      //If the element is non-zero, move it to the nonZeroIndex position
      nums[nonZeroIndex] = nums[i];
      nonZeroIndex++;
    }
  }

  //Fill the remaining elements with zeros
  for (let i = nonZeroIndex; i < nums.length; i++) {
    nums[i] = 0;
  }
};","The function first checks if the input is a valid array. Then, it iterates through the array, moving all non-zero elements to the beginning of the array while keeping their relative order. Finally, it fills the remaining positions with zeros.  This approach is efficient because it only iterates through the array twice and modifies the array in-place, avoiding the need for creating a new array.",6,10,3,5,"{""functionOrClassName"": ""moveZeroes"", ""tests"": [""moveZeroes([0,1,0,3,12])"", ""moveZeroes([0])"", ""moveZeroes([1])"", ""moveZeroes([1, 0])"", ""moveZeroes([0, 1])"", ""moveZeroes([0, 0, 0])"", ""moveZeroes([1, 1, 1])"", ""moveZeroes([0, 1, 0, 2, 0, 0, 3, 4, 0, 5])"", ""moveZeroes([1, 2, 3, 4, 5, 0, 0, 0, 0, 0])"", ""moveZeroes([0, 0, 0, 0, 0, 1, 2, 3, 4, 5])"", ""moveZeroes([-1, 0, 1])"", ""moveZeroes([-1, 0, -1, 0, 1])""]}","let moveZeroes=function(a){let c=0;for(let b=0;b<a.length;b++)0!==a[b]&&([a[b],a[c]]=[a[c],a[b]],c++);return a};
",0.19820800000000816,0.4213749999999976,0.1504589999999979,12,0,12
"/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(input) {
    var start = 0
    var end = input.length - 1
    while (start < end) {
        var s = input.charCodeAt(start)
        var e = input.charCodeAt(end)
    
        if (!isLetter(s)) {
            start++
            continue
        }
        if (!isLetter(e)) {
            end--
            continue
        }
    
        if (toLowerCase(s) !== toLowerCase(e)) {
            return false 
        } 
        start++
        end--
  }
  return true
};

var isLetter = function(code) {
    if (((code >= 48) && (code <= 57))  // numbers
    || ((code >= 65) && (code <= 90))  // uppercase
    || ((code >= 97) && (code <= 122))) {  // lowercase
        return true
    }
    else {
        return false
    }
}

var toLowerCase = function(code) {
    if (code >= 65 && code <= 90) {
        return code + 32    
    }
    else {
        return code
    }
}",Easy,"/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
  // Convert the string to lowercase and remove non-alphanumeric characters
  s = s.toLowerCase().replace(/[^a-z0-9]/g, '');

  // Check if the string is a palindrome
  let left = 0;
  let right = s.length - 1;
  while (left < right) {
    if (s[left] !== s[right]) {
      return false;
    }
    left++;
    right--;
  }

  return true;
};","The function first preprocesses the input string by converting it to lowercase and removing non-alphanumeric characters using a regular expression. Then, it uses two pointers, one at the beginning and one at the end of the string, to compare characters from both ends. If any pair of characters doesn't match, it's not a palindrome, and the function returns `false`. If the loop completes without finding any mismatches, it means the string is a palindrome, and the function returns `true`.",49,10,30,2,"{""functionOrClassName"": ""isPalindrome"", ""tests"": [""isPalindrome(\""A man, a plan, a canal: Panama\"")"", ""isPalindrome(\""race a car\"")"", ""isPalindrome(\"" \"")"", ""isPalindrome(\"".,\"")"", ""isPalindrome(\""0P\"")"", ""isPalindrome(\""a\"")"", ""isPalindrome(\""\"")"", ""isPalindrome(\""ab\"")"", ""isPalindrome(\""aba\"")"", ""isPalindrome(\""aa\"")"", ""isPalindrome(\""ab ba\"")"", ""isPalindrome(\""1ab1\"")"", ""isPalindrome(\""1221\"")"", ""isPalindrome(\""1a2b2a1\"")""]}","function f(a){return 48<=a&&57>=a||65<=a&&90>=a||97<=a&&122>=a?!0:!1}let isPalindrome=function(a){for(var d=0,e=a.length-1;d<e;){var b=a.charCodeAt(d),c=a.charCodeAt(e);if(f(b)){if(f(c)){if((65<=b&&90>=b?b+32:b)!==(65<=c&&90>=c?c+32:c))return!1;d++}e--}else d++}return!0};
",0.19400000000000261,0.4281660000000045,0.39666699999999366,14,14,14
"var isPowerOfThree = function(n) {
    if (n === 0) return false;
    if (n === 1) return true;
    
    if (!(n%3)) return isPowerOfThree(n/3);
    
    return false;
};",Easy,"/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
  if (n <= 0) return false;
  while (n % 3 === 0) {
    n /= 3;
  }
  return n === 1;
};","The function `isPowerOfThree` efficiently determines if a given integer `n` is a power of three. It first handles the base cases: if `n` is less than or equal to 0, it cannot be a power of three, so it returns `false`. Otherwise, it repeatedly divides `n` by 3 using a `while` loop as long as `n` is divisible by 3. If, after this process, `n` is equal to 1, it means that the original number was a power of three, and the function returns `true`. Otherwise, it returns `false`. This approach avoids the use of logarithms or recursion, making it efficient and easy to understand.",11,11,3,2,"{""functionOrClassName"": ""isPowerOfThree"", ""tests"": [""isPowerOfThree(0)"", ""isPowerOfThree(1)"", ""isPowerOfThree(3)"", ""isPowerOfThree(9)"", ""isPowerOfThree(27)"", ""isPowerOfThree(81)"", ""isPowerOfThree(243)"", ""isPowerOfThree(5)"", ""isPowerOfThree(10)"", ""isPowerOfThree(45)"", ""isPowerOfThree(15)"", ""isPowerOfThree(19683)"", ""isPowerOfThree(59049)"", ""isPowerOfThree(177147)"", ""isPowerOfThree(531441)"", ""isPowerOfThree(-1)"", ""isPowerOfThree(-3)"", ""isPowerOfThree(-27)"", ""isPowerOfThree(19684)"", ""isPowerOfThree(59050)"", ""isPowerOfThree(177148)""]}","function b(a){return 0===a?!1:1===a?!0:a%3?!1:b(a/3)}let isPowerOfThree=b;
",0.17483299999999247,0.14929199999998843,0.3478330000000085,21,21,21
"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    let obj={}
    for(let n of nums){
        obj[n]=1
    }
    let arr=[]
    for(let i=1;i<=nums.length;i++){
        if(!obj[i]) arr.push(i)
    }
    return arr
};",Easy,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
  //Error Handling: Check if input is valid
  if (!Array.isArray(nums) || nums.length === 0) {
    return []; //Return empty array for invalid input
  }

  const n = nums.length;
  const numSet = new Set(nums);
  const result = [];

  for (let i = 1; i <= n; i++) {
    if (!numSet.has(i)) {
      result.push(i);
    }
  }

  return result;
};","The function first checks for invalid input. It then uses a Set to efficiently track the numbers present in the input array.  The code iterates through the range [1, n] and adds any number not found in the Set to the result array. This approach has a time complexity of O(n) due to the single loop and Set operations, making it efficient for large input arrays.",11,10,12,8,"{""functionOrClassName"": ""findDisappearedNumbers"", ""tests"": [""findDisappearedNumbers([4,3,2,7,8,2,3,1])"", ""findDisappearedNumbers([1,1])"", ""findDisappearedNumbers([1,2,3,4,5,6,7,8])"", ""findDisappearedNumbers([1])"", ""findDisappearedNumbers([])"", ""findDisappearedNumbers([1,2,2,2,2,2,2,2])"", ""findDisappearedNumbers([1,2,2,4,5,6,7,8])"", ""findDisappearedNumbers([1,1,1,1,1,1,1,1])"", ""findDisappearedNumbers([2,2,3,3,4,4,5,5])"", ""findDisappearedNumbers([1,2,3,4,5,6,7,7])""]}","let findDisappearedNumbers=function(c){let d={};for(var a of c)d[a]=1;a=[];for(let b=1;b<=c.length;b++)d[b]||a.push(b);return a};
",0.17225000000000534,0.1331249999999926,0.12487499999998875,10,10,10
"/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    cost.push(0);

    for (let i = cost.length - 4; i >= 0; i--) {
        cost[i] += Math.min(cost[i + 1], cost[i + 2]);
    }

    return Math.min(cost[0], cost[1]);    
};",Easy,"/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
  if (!cost || cost.length === 0) {
    return 0; // Handle empty input
  }

  const n = cost.length;
  // Create a DP array to store minimum costs to reach each step
  const dp = new Array(n + 1).fill(Infinity);
  dp[0] = 0; // Cost to reach step 0 is 0
  dp[1] = 0; // Cost to reach step 1 is 0 (assuming we start from step 0 or 1)

  for (let i = 2; i <= n; i++) {
    // Minimum cost to reach current step is the minimum of:
    // 1. Cost to reach current step from the previous step
    // 2. Cost to reach current step from the step before the previous step
    dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
  }

  return dp[n]; // Minimum cost to reach the top
};","The solution uses dynamic programming.  A DP array `dp` stores the minimum cost to reach each step. `dp[i]` is the minimum cost to reach step `i`.  The base cases are `dp[0] = 0` and `dp[1] = 0` (we can start from either step 0 or 1). The recurrence relation is `dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`. The final answer is `dp[n]`, where n is the number of steps. Error handling is included to check for empty input.",12,20,5,5,"{""functionOrClassName"": ""minCostClimbingStairs"", ""tests"": [""minCostClimbingStairs([10,15,20])"", ""minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1])"", ""minCostClimbingStairs([0,0,0,0])"", ""minCostClimbingStairs([1,2,3,4,5,6,7,8,9,10])"", ""minCostClimbingStairs([1,1,1,1,1,1,1,1,1,1])"", ""minCostClimbingStairs([1,2])"", ""minCostClimbingStairs([0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5])"", ""minCostClimbingStairs([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5\"")""]}","let minCostClimbingStairs=function(a){a.push(0);for(let b=a.length-4;0<=b;b--)a[b]+=Math.min(a[b+1],a[b+2]);return Math.min(a[0],a[1])};
",0.25337499999999125,0.13766700000000753,0.1721249999999941,8,8,8
"/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    let res = """";
    let x=0, y=0, rem=0;
    while(a!="""" || b!="""") {
        if(a!="""") {
            x = parseInt(a.slice(-1));
            a = a.slice(0,-1);
        }
        if(b!="""") {
            y = parseInt(b.slice(-1));
            b = b.slice(0,-1);
        }
        if(x+y+rem == 2) {
            rem=1;
            res = ""0"" + res;
        }
        else if(x+y+rem == 3) {
            rem=1;
            res = ""1"" + res;
        }
        else {
            res = (x+y+rem).toString() + res;
            rem=0;
        }
        x=0;
        y=0;
    }
    if(rem==1) res = ""1"" + res;
    return res;

};",Easy,"/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
  let i = a.length - 1;
  let j = b.length - 1;
  let carry = 0;
  let result = '';

  while (i >= 0 || j >= 0 || carry) {
    const sum = (i >= 0 ? parseInt(a[i]) : 0) + (j >= 0 ? parseInt(b[j]) : 0) + carry;
    result = (sum % 2) + result;
    carry = Math.floor(sum / 2);
    i--;
    j--;
  }

  return result;
};","The function iterates through the input strings from right to left, adding digits and handling carry.  parseInt converts string digits to numbers. The modulo operator (%) gets the remainder (0 or 1), and Math.floor() gets the integer part of the division (carry). The result is built up from right to left.",39,27,4,4,"{""functionOrClassName"": ""addBinary"", ""tests"": [""addBinary(\""11\"", \""1\"")"", ""addBinary(\""1010\"", \""1011\"")"", ""addBinary(\""1\"", \""0\"")"", ""addBinary(\""0\"", \""0\"")"", ""addBinary(\""111\"", \""111\"")"", ""addBinary(\""100\"", \""110010\"")"", ""addBinary(\""11\"", \""100\"")"", ""addBinary(\""101\"", \""1\"")"", ""addBinary(\""1\"", \""1111\"")"", ""addBinary(\""1111\"", \""1111\"")"", ""addBinary(\""0\"", \""1\"")"", ""addBinary(\""1\"", \""1\"")""]}","let addBinary=function(c,d){let a="""",e=0,f=0,b=0;for(;""""!=c||""""!=d;)""""!=c&&(e=parseInt(c.slice(-1)),c=c.slice(0,-1)),""""!=d&&(f=parseInt(d.slice(-1)),d=d.slice(0,-1)),2==e+f+b?(b=1,a=""0""+a):3==e+f+b?(b=1,a=""1""+a):(a=(e+f+b).toString()+a,b=0),f=e=0;1==b&&(a=""1""+a);return a};
",0.19029199999999946,0.43004199999998605,0.14074999999999704,12,12,12
"/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    const seen = new Set();
    
    while (n !== 1 && !seen.has(n)) {
        seen.add(n);
        let sum = 0;
        
        let numStr = n.toString();
        for (let i = 0; i < numStr.length; i++) {
            let digit = Number(numStr[i]);
            sum += digit * digit;
        }
        
        n = sum;  
    }
    return n === 1;
};",Easy,"/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
  if (n <= 0) {
    throw new Error(""Input must be a positive integer."");
  }

  const seen = new Set();
  while (!seen.has(n)) {
    seen.add(n);
    n = sumOfSquaresOfDigits(n);
    if (n === 1) {
      return true;
    }
  }
  return false;
};

function sumOfSquaresOfDigits(n) {
  let sum = 0;
  while (n > 0) {
    const digit = n % 10;
    sum += digit * digit;
    n = Math.floor(n / 10);
  }
  return sum;
}",The algorithm uses a Set to track numbers encountered during the process. It iteratively calculates the sum of squares of digits until either 1 is reached (happy number) or a cycle is detected (unhappy number). Error handling is included to ensure that the input is a positive integer. The sumOfSquaresOfDigits function is a helper function to calculate the sum of squares of digits efficiently.,12,14,2,3,"{""functionOrClassName"": ""isHappy"", ""tests"": [""isHappy(1)"", ""isHappy(2)"", ""isHappy(7)"", ""isHappy(10)"", ""isHappy(13)"", ""isHappy(19)"", ""isHappy(23)"", ""isHappy(28)"", ""isHappy(31)"", ""isHappy(32)"", ""isHappy(100)"", ""isHappy(999)"", ""isHappy(2023)"", ""isHappy(123456789)"", ""isHappy(987654321)"", ""isHappy(Number.MAX_SAFE_INTEGER)"", ""isHappy(1111111)"", ""isHappy(7777777)"", ""isHappy(123123123)"", ""isHappy(999999999)""]}","let isHappy=function(a){const c=new Set;for(;1!==a&&!c.has(a);){c.add(a);let d=0;a=a.toString();for(let b=0;b<a.length;b++){let e=Number(a[b]);d+=e*e}a=d}return 1===a};
",0.28249999999999886,0.4636249999999933,0.23995800000000145,20,20,20
"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    if (!root) return 0
    let leftSubHeight = maxDepth(root.left)
    let rightSubHeight = maxDepth(root.right) 
    return Math.max(leftSubHeight, rightSubHeight) + 1
};",Easy,"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(root === null) return 0;
    let leftDepth = maxDepth(root.left);
    let rightDepth = maxDepth(root.right);
    return Math.max(leftDepth, rightDepth) + 1; 
};","The solution uses a recursive depth-first search approach.  The base case is an empty tree (root is null), returning a depth of 0. Otherwise, it recursively calculates the maximum depth of the left and right subtrees and returns the maximum of these depths plus 1 (to account for the current node). This efficiently finds the longest path from root to leaf.",9,9,8,4,"{""functionOrClassName"": ""maxDepth"", ""tests"": [""maxDepth(null)"", ""maxDepth(new TreeNode(1))"", ""maxDepth(new TreeNode(1, new TreeNode(2), null))"", ""maxDepth(new TreeNode(1, null, new TreeNode(2)))"", ""maxDepth(new TreeNode(1, new TreeNode(2), new TreeNode(3)))"", ""maxDepth(new TreeNode(1, new TreeNode(2, new TreeNode(4), null), new TreeNode(3)))"", ""maxDepth(new TreeNode(1, new TreeNode(2, null, new TreeNode(4)), new TreeNode(3)))"", ""maxDepth(new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3)))"", ""maxDepth(new TreeNode(1, new TreeNode(2), new TreeNode(3, new TreeNode(4), new TreeNode(5))))"", ""maxDepth(new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(5)), new TreeNode(6)), new TreeNode(3, new TreeNode(7), new TreeNode(8))))"", ""maxDepth(new TreeNode(3, new TreeNode(9), new TreeNode(20, new TreeNode(15), new TreeNode(7))))"", ""maxDepth(new TreeNode(1, new TreeNode(2, new TreeNode(3, new TreeNode(4, new TreeNode(5)))))"", ""maxDepth(new TreeNode(0, new TreeNode(-1), new TreeNode(1)))""]}","function a(b){return b?Math.max(a(b.left),a(b.right))+1:0}let maxDepth=a;
",0.3203749999999985,0.1957919999999973,0.20633399999999824,13,13,13
"/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {
  
    let nodeA = headA;
    let nodeB = headB;
    
    
    while (nodeA !== nodeB) {
        
        nodeA = !nodeA ? headB : nodeA.next;
        
        nodeB = !nodeB ? headA : nodeB.next;
    }
    
    
    return nodeA;
};",Easy,"/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
  if (!headA || !headB) return null;

  let a = headA;
  let b = headB;

  while (a !== b) {
    a = a === null ? headB : a.next;
    b = b === null ? headA : b.next;
  }

  return a;
};","The code uses two pointers, `a` and `b`, to traverse the linked lists.  Pointer `a` starts at `headA` and pointer `b` starts at `headB`. In each iteration, if a pointer reaches the end of its list, it's moved to the beginning of the other list. This continues until both pointers point to the same node (the intersection) or both reach null (no intersection). The time complexity is O(m+n), where m and n are the lengths of the lists, and space complexity is O(1). This approach efficiently handles the case where lists intersect or don't intersect.",8,9,8,8,"{""functionOrClassName"": ""getIntersectionNode"", ""tests"": [""(() => {const listA = {val: 4, next: {val: 1, next: {val: 8, next: {val: 4, next: {val: 5, next: null}}}}}; const listB = {val: 5, next: {val: 6, next: {val: 1, next: {val: 8, next: {val: 4, next: {val: 5, next: null}}}}}}; return getIntersectionNode(listA, listB);})()"", ""(() => {const listA = {val: 1, next: {val: 9, next: {val: 1, next: {val: 2, next: {val: 4, next: null}}}}}; const listB = {val: 3, next: {val: 2, next: {val: 4, next: null}}}; return getIntersectionNode(listA, listB);})()"", ""(() => {const listA = {val: 2, next: {val: 6, next: {val: 4, next: null}}}; const listB = {val: 1, next: {val: 5, next: null}}; return getIntersectionNode(listA, listB);})()"", ""getIntersectionNode(null, null)"", ""(() => {const listA = {val: 1, next: null}; return getIntersectionNode(listA, listA);})()"", ""(() => {const listA = {val: 1, next: {val: 2, next: null}}; const listB = listA.next; return getIntersectionNode(listA, listB);})()"", ""(() => {const listA = {val: 1, next: {val: 2, next: {val: 3, next: null}}}; const listB = {val: 1, next: {val: 2, next: {val: 3, next: null}}}; return getIntersectionNode(listA, listB);})()"", ""(() => {const listA = {val: 1, next: {val: 3, next: {val: 5, next: {val: 7, next: {val: 9, next: {val: 11, next: null}}}}}}; const listB = {val: 2, next: {val: 4, next: {val: 6, next: {val: 8, next: {val: 10, next: null}}}}} ; return getIntersectionNode(listA, listB);})()"", ""(() => {const listA = {val: 1, next: null}; const listB = {val: 2, next: null}; return getIntersectionNode(listA, listB);})()"", ""(() => { return getIntersectionNode(null, {val: 1, next: null});})()"", ""(() => {const listA = {val: 1, next: {val: 2, next: {val: 3, next: {val: 4, next: {val: 5, next: null}}}}}; const listB = {val: 6, next: {val: 7, next: listA.next.next}}; return getIntersectionNode(listA, listB);})()""]}","let getIntersectionNode=function(c,d){let a=c,b=d;for(;a!==b;)a=a?a.next:d,b=b?b.next:c;return a};
",0.23587500000000716,0.19420799999998906,0.19095900000000654,11,11,11
"var minDistance = function(word1, word2) {
    const cache = {}
    function dp(i, j) {
        if (cache[`${i}->${j}`] !== undefined) {
            return cache[`${i}->${j}`]
        }
        if (i >= word1.length) {
            return word2.length - j;
        } 
        if (j >= word2.length) {
            return word1.length - i;
        }
        if (word1[i] === word2[j]) {
            return dp(i+1, j+1);
        }
        let insert = 1 + dp(i, j+1);
        let del = 1 + dp(i+1, j);
        let repl = 1 + dp(i+1, j+1);
        const res = Math.min(insert, del, repl);
        cache[`${i}->${j}`] = res;
        return res;
    }
    return dp(0, 0)
};",Medium,"/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function(word1, word2) {
  const m = word1.length;
  const n = word2.length;

  // Create a DP table to store results of subproblems
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

  // Initialize the first row and column of the DP table
  for (let i = 0; i <= m; i++) {
    dp[i][0] = i;
  }
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j;
  }

  // Fill in the rest of the DP table
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]; // No operation needed if characters are the same
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1, // Deletion
          dp[i][j - 1] + 1, // Insertion
          dp[i - 1][j - 1] + 1 // Replacement
        );
      }
    }
  }

  return dp[m][n]; // The minimum edit distance is in the bottom-right corner
};","The solution uses dynamic programming. A DP table `dp` is created where `dp[i][j]` represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. The table is filled iteratively, using the recurrence relation: `dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (word1[i-1] != word2[j-1]))`. The final result is `dp[m][n]`, where `m` and `n` are the lengths of `word1` and `word2` respectively.  The base cases are initialized to handle empty strings.",24,37,6,2,"{""functionOrClassName"": ""minDistance"", ""tests"": [""minDistance(\""horse\"", \""ros\"")"", ""minDistance(\""intention\"", \""execution\"")"", ""minDistance(\""a\"", \""b\"")"", ""minDistance(\""ab\"", \""bc\"")"", ""minDistance(\""abc\"", \""adc\"")"", ""minDistance(\""sea\"", \""eat\"")"", ""minDistance(\""leetcode\"", \""etco\"")"", ""minDistance(\""\"", \""\"")"", ""minDistance(\""a\"", \""\"")"", ""minDistance(\""\"", \""a\"")"", ""minDistance(\""park\"", \""spake\"")"", ""minDistance(\""mart\"", \""karma\"")"", ""minDistance(\""dinitrophenylhydrazine\"", \""benzalphenylhydrazone\"")""]}","let minDistance=function(d,e){function c(a,b){if(void 0!==f[`${a}->${b}`])return f[`${a}->${b}`];if(a>=d.length)return e.length-b;if(b>=e.length)return d.length-a;if(d[a]===e[b])return c(a+1,b+1);var g=1+c(a,b+1);let h=1+c(a+1,b),k=1+c(a+1,b+1);g=Math.min(g,h,k);return f[`${a}->${b}`]=g}const f={};return c(0,0)};
",1.1792080000000027,1.7490829999999988,0.529083,13,13,13
"/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    if(!nums.length) return 0;
    
    let count = 1;
    let largestSequence = 0;
    
    nums = new Set(nums);
    nums = Array.from(nums);
    nums.sort((a,b)=> a-b);
   

    for(let i=0 ; i<nums.length ; i++){
        let diff = nums[i+1] - nums[i]; 
        if(diff == 1){
             count++;
        }else{
            if(count > largestSequence){
                largestSequence = count;
            }
            count = 1;
        }

    }
    return largestSequence;;
};",Medium,"/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
  if (!nums || nums.length === 0) return 0;

  const numSet = new Set(nums);
  let longestStreak = 0;

  for (const num of numSet) {
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentStreak = 1;

      while (numSet.has(currentNum + 1)) {
        currentNum += 1;
        currentStreak += 1;
      }

      longestStreak = Math.max(longestStreak, currentStreak);
    }
  }

  return longestStreak;
};","The function first handles edge cases where the input array is null or empty. It then uses a Set to store the unique numbers in the input array for efficient lookup. The algorithm iterates through each number in the Set. If a number is not preceded by a consecutive number (meaning it's the start of a potential sequence), it starts counting the consecutive numbers until it encounters a gap. The longest streak is updated accordingly. The time complexity is O(n) because of the single iteration through the Set, and the space complexity is O(n) due to the Set.",19,12,6,5,"{""functionOrClassName"": ""longestConsecutive"", ""tests"": [""longestConsecutive([100,4,200,1,3,2])"", ""longestConsecutive([0,3,7,2,5,8,4,6,0,1])"", ""longestConsecutive([1,2,3,4,5,6,7,8,9,10])"", ""longestConsecutive([])"", ""longestConsecutive([1])"", ""longestConsecutive([1,3,5,7,9])"", ""longestConsecutive([1,1,1,1,1])"", ""longestConsecutive([-1,0,1])"", ""longestConsecutive([9,1,4,7,3,-1,0,5,8,-1,6])"", ""longestConsecutive([1,2,0,1])"", ""longestConsecutive([0])"", ""longestConsecutive([1,5,2,4,3])"", ""longestConsecutive([10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10])"", ""longestConsecutive([100, 200, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50])""]}","let longestConsecutive=function(a){if(!a.length)return 0;let c=1,d=0;a=new Set(a);a=Array.from(a);a.sort((b,e)=>b-e);for(let b=0;b<a.length;b++)1==a[b+1]-a[b]?c++:(c>d&&(d=c),c=1);return d};
",0.26191699999999685,0.43591700000000344,0.1997080000000011,14,14,14
"var shortestPalindrome = function(s) {
    let count = kmp(s.split('').reverse().join(''), s);
    return s.slice(count).split('').reverse().join('') + s;
};

var kmp = function(txt, patt) {
    let newString = patt + '#' + txt;
    let pi = new Array(newString.length).fill(0);
    let i = 1, k = 0;
    while (i < newString.length) {
        if (newString[i] === newString[k]) {
            k++;
            pi[i] = k;
            i++;
        } else {
            if (k > 0) {
                k = pi[k - 1];
            } else {
                pi[i] = 0;
                i++;
            }
        }
    }
    return pi[newString.length - 1];
};",Hard,"/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
  if (!s || s.length === 0) return """";

  const reversed = s.split("""").reverse().join("""");
  let i = 0;
  while (i < s.length && s.substring(0, s.length - i) !== reversed.substring(i)) {
    i++;
  }

  return reversed.substring(0, i) + s;
};","The function `shortestPalindrome` takes a string `s` as input and returns the shortest palindrome that can be formed by adding characters to the beginning of `s`. It first reverses the input string. Then, it iterates through the string to find the longest prefix that is also a suffix of the reversed string. Finally, it adds the remaining part of the reversed string to the beginning of the original string to form the shortest palindrome.",25,10,5,2,"{""functionOrClassName"": ""shortestPalindrome"", ""tests"": [""shortestPalindrome(\""aacecaaa\"")"", ""shortestPalindrome(\""abcd\"")"", ""shortestPalindrome(\""aba\"")"", ""shortestPalindrome(\""a\"")"", ""shortestPalindrome(\""\"")"", ""shortestPalindrome(\""racecar\"")"", ""shortestPalindrome(\""abacaba\"")"", ""shortestPalindrome(\""madam\"")"", ""shortestPalindrome(\""level\"")"", ""shortestPalindrome(\""deified\"")"", ""shortestPalindrome(\""rotor\"")"", ""shortestPalindrome(\""aabba\"")"", ""shortestPalindrome(\""aaaaaaaaaaaaaaaaaaaaaaaa\"")"", ""shortestPalindrome(\""aaba\"")"", ""shortestPalindrome(\""abb\"")""]}","let shortestPalindrome=function(d){var a=d.split("""").reverse().join("""");a=d+""#""+a;let e=Array(a.length).fill(0),b=1,c=0;for(;b<a.length;)a[b]===a[c]?(c++,e[b]=c,b++):0<c?c=e[c-1]:(e[b]=0,b++);return d.slice(e[a.length-1]).split("""").reverse().join("""")+d};
",0.29716700000000174,0.5733749999999986,0.16279199999999605,15,15,15
"var findLadders = function(beginWord, endWord, wordList) {
    if (!wordList.includes(endWord)) return [];
    
    const result = [], map = new Map(), steps = new Map();
	
    for (const word of wordList) {
        for (let i = 0; i < word.length; i++) {
            const hash = word.substring(0, i) + '*' + word.substring(i + 1);
			
            if (!map.has(hash)) map.set(hash, []);
			
            map.get(hash).push(word);
            steps.set(hash, wordList.length);
        }
    }
    
    const queue = [[beginWord]];
	
    while (queue.length > 0) {
        const current = queue.shift();
        const set = new Set(current);
        const lastWord = current[current.length - 1];
        if (lastWord === endWord) {
            if (result.length === 0 || current.length === result[0].length)
                result.push(current);
            else break;
        } else {
            for (let i = 0; i < lastWord.length; i++) {
                const hash = lastWord.substring(0, i) + '*' + lastWord.substring(i + 1);
                if (!map.has(hash) || current.length > steps.get(hash))
					continue;
					
                for (const nextWord of map.get(hash))
                    if (!set.has(nextWord))
						queue.push([...current, nextWord]);
						
                steps.set(hash, current.length);
            }
        }
    }
    return result;
};",Hard,"/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
  if (!wordList.includes(endWord)) return [];
  const wordSet = new Set(wordList);
  const queue = [[beginWord]];
  const result = [];
  const visited = new Set();
  visited.add(beginWord);

  while (queue.length > 0) {
    const currentLevel = queue.shift();
    const lastWord = currentLevel[currentLevel.length - 1];
    if (lastWord === endWord) {
      result.push(currentLevel);
      continue; // Found a path, move to the next
    }

    for (let i = 0; i < lastWord.length; i++) {
      for (let j = 0; j < 26; j++) {
        const charCode = 'a'.charCodeAt(0) + j;
        const newWord = lastWord.substring(0, i) + String.fromCharCode(charCode) + lastWord.substring(i + 1);
        if (wordSet.has(newWord) && !visited.has(newWord)) {
          visited.add(newWord);
          queue.push([...currentLevel, newWord]);
        }
      }
    }
  }
  return result;
};","The function uses Breadth-First Search (BFS) to find all shortest transformation sequences. It starts with the beginWord and explores its neighbors (words differing by one letter).  It uses a queue to manage the search and a visited set to avoid cycles.  The algorithm continues until it finds the endWord or exhausts all possible paths. The result is an array of arrays, where each inner array represents a shortest transformation sequence.",31,22,3,8,"{""functionOrClassName"": ""findLadders"",
  ""tests"": [
    ""findLadders(\""hit\"", \""cog\"", [\""hot\"",\""dot\"",\""dog\"",\""lot\"",\""log\"",\""cog\""])"",
    ""findLadders(\""hit\"", \""cog\"", [\""hot\"",\""dot\"",\""dog\"",\""lot\"",\""log\""])"",
    ""findLadders(\""hit\"", \""cog\"", [])"",
    ""findLadders(\""red\"", \""tax\"", [\""ted\"",\""tex\"",\""red\"",\""tax\"",\""tad\"",\""den\"",\""rex\"",\""pee\""])"",
    ""findLadders(\""red\"", \""tax\"", [\""ted\"",\""tex\"",\""red\"",\""tad\"",\""den\"",\""rex\"",\""pee\""])"",
    ""findLadders(\""a\"", \""c\"", [\""a\"", \""b\"", \""c\""])"",
    ""findLadders(\""hot\"", \""dog\"", [\""hot\"", \""dog\""])"",
    ""findLadders(\""leet\"", \""code\"", [\""lest\"",\""leet\"",\""lose\"",\""code\"",\""lode\"",\""robe\"",\""lost\""])"",
    ""findLadders(\""talk\"", \""tail\"", [\""talk\"",\""tons\"",\""fall\"",\""tail\"",\""gale\"",\""hall\"",\""neal\"",\""tale\"",\""teal\""])"",
    ""findLadders(\""magic\"", \""pearl\"", [\""magic\"",\""manic\"",\""mania\"",\""maniaq\"",\""maniah\"",\""maniai\"",\""manial\"",\""manip\"",\""manis\"",\""manit\"",\""maniu\"",\""maniv\"",\""maniw\"",\""maniy\"",\""maniz\"",\""manja\"",\""manjb\"",\""manjc\"",\""manjd\"",\""manje\"",\""manjf\"",\""manjg\"",\""manjh\"",\""manji\"",\""manjj\"",\""manjk\"",\""manjl\"",\""manjm\"",\""manjn\"",\""manjo\"",\""manjp\"",\""manjq\"",\""manjr\"",\""manjs\"",\""manjt\"",\""manju\"",\""manjv\"",\""manjw\"",\""manjx\"",\""manjy\"",\""manjz\"",\""manka\"",\""mankb\"",\""mankc\"",\""mankd\"",\""manke\"",\""mankf\"",\""mankg\"",\""mankh\"",\""manki\"",\""mankj\"",\""mankk\"",\""mankl\"",\""mankm\"",\""mankn\"",\""manko\"",\""mankp\"",\""mankq\"",\""mankr\"",\""manks\"",\""mankt\"",\""manku\"",\""mankv\"",\""mankw\"",\""mankx\"",\""manky\"",\""mankz\"",\""manla\"",\""manlb\"",\""manlc\"",\""manld\"",\""manle\"",\""manlf\"",\""manlg\"",\""manlh\"",\""manli\"",\""manlj\"",\""manlk\"",\""manll\"",\""manlm\"",\""manln\"",\""manlo\"",\""manlp\"",\""manlq\"",\""manlr\"",\""manls\"",\""manlt\"",\""manlu\"",\""manlv\"",\""manlw\"",\""manlx\"",\""manly\"",\""manlz\"",\""manma\"",\""manmb\"",\""pearl\""])"",
    ""findLadders(\""cet\"", \""ism\"", [\""kid\"",\""tag\"",\""pup\"",\""ail\"",\""tun\"",\""tap\"",\""car\"",\""hat\"",\""pan\"",\""map\"",\""sad\"",\""cab\"",\""ace\"",\""bar\"",\""apt\"",\""bag\"",\""bit\"",\""pie\"",\""bad\"",\""sit\"",\""mad\"",\""pit\"",\""rad\"",\""cat\"",\""pat\"",\""tap\"",\""bat\"",\""tan\"",\""bam\"",\""can\"",\""van\"",\""ram\"",\""pav\"",\""bip\"",\""jib\"",\""bil\"",\""dip\"",\""yap\"",\""sib\"",\""piz\"",\""bam\"",\""zep\"",\""ray\"",\""zip\"",\""zap\"",\""mac\"",\""cap\"",\""sap\"",\""gap\"",\""fab\"",\""hip\"",\""has\"",\""cat\"",\""tad\"",\""arc\"",\""has\"",\""top\"",\""sip\"",\""bit\"",\""bag\"",\""gas\"",\""yip\"",\""tip\"",\""toe\"",\""tap\"",\""tin\"",\""tip\"",\""top\"",\""sip\"",\""fox\"",\""fin\"",\""fit\"",\""hip\"",\""hop\"",\""gap\"",\""jay\"",\""pat\"",\""roy\"",\""ban\"",\""jay\"",\""zap\"",\""cap\"",\""fat\"",\""tap\"",\""cat\"",\""dap\"",\""cap\"",\""bar\"",\""bop\"",\""top\"",\""tar\"",\""cap\"",\""zap\"",\""pap\"",\""rap\"",\""lap\"",\""tat\"",\""pat\"",\""gap\"",\""lab\"",\""lap\"",\""tag\"",\""tap\"",\""bop\"",\""tar\"",\""rad\"",\""tao\"",\""tad\"",\""tin\"",\""pap\"",\""pit\"",\""tap\"",\""tad\"",\""tap\"",\""dad\"",\""tap\"",\""dot\"",\""dab\"",\""dap\"",\""bit\"",\""bar\"",\""tap\"",\""tap\"",\""yap\"",\""car\"",\""nap\"",\""tap\"",\""tar\"",\""tam\"",\""tep\"",\""taw\"",\""pep\""])""
  ]
}","let findLadders=function(e,l,a){if(!a.includes(l))return[];const g=[],f=new Map,k=new Map;for(var d of a)for(var b=0;b<d.length;b++){var c=d.substring(0,b)+""*""+d.substring(b+1);f.has(c)||f.set(c,[]);f.get(c).push(d);k.set(c,a.length)}for(e=[[e]];0<e.length;)if(a=e.shift(),d=new Set(a),b=a[a.length-1],b===l)if(0===g.length||a.length===g[0].length)g.push(a);else break;else for(c=0;c<b.length;c++){const h=b.substring(0,c)+""*""+b.substring(c+1);if(f.has(h)&&!(a.length>k.get(h))){for(const m of f.get(h))d.has(m)||
e.push([...a,m]);k.set(h,a.length)}}return g};
",2.021500000000003,2.4505000000000052,2.813665999999998,11,9,11
"const isMatch = function (string, pattern) {
  let s = 0, p = 0;
  let starIdx = -1, pointer = -1;

  while (s < string.length) {
    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === ""?"") {
      s++;
      p++;
    } 
	else if (p < pattern.length && pattern[p] === ""*"") {
      starIdx = p;
      pointer = s;
      p++;
    } 
	else if (starIdx === -1) return false;
    else {
      p = starIdx + 1;
      s = pointer + 1;
      pointer = s;
    }
  }
  for (let idx = p; idx < pattern.length; idx++) {
    if (pattern[idx] !== ""*"") return false;
  }
  return true;
};",Hard,"/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  if (typeof s !== 'string' || typeof p !== 'string') {
    throw new Error('Inputs must be strings.');
  }

  const m = s.length;
  const n = p.length;

  const dp = Array(m + 1).fill(false).map(() => Array(n + 1).fill(false));
  dp[0][0] = true;

  for (let j = 1; j <= n; j++) {
    if (p[j - 1] === '*') {
      dp[0][j] = dp[0][j - 1];
    }
  }

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (p[j - 1] === '*') {
        dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
      } else if (p[j - 1] === '?' || s[i - 1] === p[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      }
    }
  }

  return dp[m][n];
};","The solution uses dynamic programming. A 2D array `dp` is created where `dp[i][j]` represents whether the first `i` characters of `s` match the first `j` characters of `p`. The base cases are handled, and the algorithm iterates through the strings, updating `dp` based on the characters and wildcard characters ('?', '*'). The final result is stored in `dp[m][n]`, where `m` and `n` are the lengths of `s` and `p`, respectively. Error handling is included to ensure that inputs are strings.",17,32,2,2,"{""functionOrClassName"": ""isMatch"", ""tests"": [""isMatch(\""aa\"", \""a\"")"", ""isMatch(\""aa\"", \""*\"")"", ""isMatch(\""cb\"", \""?a\"")"", ""isMatch(\""adceb\"", \""*a*b\"")"", ""isMatch(\""acdcb\"", \""a*c?b\"")"", ""isMatch(\""aa\"", \""aa\"")"", ""isMatch(\""aaa\"", \""aa\"")"", ""isMatch(\""aa\"", \""a*\"")"", ""isMatch(\""aa\"", \""?*\"")"", ""isMatch(\""ab\"", \""?*\"")"", ""isMatch(\""aab\"", \""c*a*b\"")"", ""isMatch(\""mississippi\"", \""m??*ss*?i*pi\"")""]}","let isMatch=function(c,b){let d=0,a=0,e=-1,f=-1;for(;d<c.length;)if(a<b.length&&c[d]===b[a]||""?""===b[a])d++,a++;else if(a<b.length&&""*""===b[a])e=a,f=d,a++;else{if(-1===e)return!1;a=e+1;f=d=f+1}for(c=a;c<b.length;c++)if(""*""!==b[c])return!1;return!0};
",0.18224999999999625,0.25549999999999784,0.2254169999999931,12,12,12
"var isMatch = function(s, p) {
    const m = s.length, n = p.length;
    const dp = new Array(m+1).fill().map(() => new Array(n+1).fill(false));
    dp[0][0] = true; // empty pattern matches empty string

    // initialize first row (empty string)
    for (let j = 1; j <= n; j++) {
        if (p[j-1] === '*')
        dp[0][j] = dp[0][j-2];
    }

    // fill in remaining cells
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
        if (s[i-1] === p[j-1] || p[j-1] === '.') {
            dp[i][j] = dp[i-1][j-1];
        } else if (p[j-1] === '*') {
            dp[i][j] = dp[i][j-2]; // zero occurrences
            if (s[i-1] === p[j-2] || p[j-2] === '.') {
            dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences
            }
        }
        }
    }
    return dp[m][n];
}",Hard,"/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  const m = s.length;
  const n = p.length;

  // Create a DP table to store results of subproblems
  const dp = Array(m + 1).fill(false).map(() => Array(n + 1).fill(false));

  // Empty string matches empty pattern
  dp[0][0] = true;

  // Handle patterns with leading '*'
  for (let j = 1; j <= n; j++) {
    if (p[j - 1] === '*') {
      dp[0][j] = dp[0][j - 2];
    }
  }

  // Fill the DP table
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (p[j - 1] === '.') {
        dp[i][j] = dp[i - 1][j - 1];
      } else if (p[j - 1] === '*') {
        dp[i][j] = dp[i][j - 2]; // Match zero occurrences
        if (p[j - 2] === '.' || p[j - 2] === s[i - 1]) {
          dp[i][j] = dp[i][j] || dp[i - 1][j]; // Match one or more occurrences
        }
      } else if (p[j - 1] === s[i - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      }
    }
  }

  return dp[m][n];
};","The solution uses dynamic programming.  A DP table `dp[i][j]` stores whether the first `i` characters of string `s` match the first `j` characters of pattern `p`. The table is filled iteratively, considering cases for '.' and '*'. Base cases handle empty strings and patterns starting with '*'. The final result is stored in `dp[m][n]`.",44,40,5,2,"{""functionOrClassName"": ""isMatch"", ""tests"": [""isMatch(\""aa\"", \""a\"")"", ""isMatch(\""aa\"", \""a*\"")"", ""isMatch(\""ab\"", \"".*\"")"", ""isMatch(\""aab\"", \""c*a*b\"")"", ""isMatch(\""mississippi\"", \""mis*is*p*.\"")"", ""isMatch(\""ab\"", \""a.*\"")"", ""isMatch(\""aaa\"", \""a*a\"")"", ""isMatch(\""aaa\"", \""ab*a*c*a\"")"", ""isMatch(\""a\"", \""ab*\"")"", ""isMatch(\""a\"", \"".\"")"", ""isMatch(\""bbbba\"", \"".*a*a\"")"", ""isMatch(\""ab\"", \"".*c\"")"", ""isMatch(\""aaaaaaaaaaaaab\"", \""a*a*a*a*a*a*a*a*a*a*c\"")""]}","let isMatch=function(f,d){const g=f.length,e=d.length,c=Array(g+1).fill().map(()=>Array(e+1).fill(!1));c[0][0]=!0;for(var a=1;a<=e;a++)""*""===d[a-1]&&(c[0][a]=c[0][a-2]);for(a=1;a<=g;a++)for(let b=1;b<=e;b++)f[a-1]===d[b-1]||"".""===d[b-1]?c[a][b]=c[a-1][b-1]:""*""===d[b-1]&&(c[a][b]=c[a][b-2],f[a-1]===d[b-2]||"".""===d[b-2])&&(c[a][b]=c[a][b]||c[a-1][b]);return c[g][e]};
",0.6230419999999981,0.5063329999999979,0.28087499999999466,13,13,13
"/**
 * @param {number[]} balloons - The input array representing the balloon values.
 * @return {number} - The maximum coins that can be collected.
 */
var maxCoins = function(balloons) {
    const n = balloons.length;

    // Pad the `balloons` array with 1 on both sides to simplify boundary cases
    balloons.push(1);
    balloons.unshift(1);

    // Create a DP table initialized with 0, with size (n+2) x (n+2)
    const dp = Array.from({ length: n + 2 }, () => Array(n + 2).fill(0));

    // Iterate backwards over all possible subarray starting points
    for (let left = n; left >= 1; left--) {
        // Iterate over all possible subarray ending points
        for (let right = left; right <= n; right++) {
            let maxCoins = -Infinity; // Store the maximum coins for subarray [left, right]

            // Try bursting each balloon `idx` in the range as the last balloon
            for (let lastBurst = left; lastBurst <= right; lastBurst++) {
                // Calculate the coins for bursting balloon `lastBurst` last
                const coins = balloons[left - 1] * balloons[lastBurst] * balloons[right + 1] +
                              dp[left][lastBurst - 1] + dp[lastBurst + 1][right];

                // Update the maximum coins for this subarray
                maxCoins = Math.max(maxCoins, coins);
            }

            // Store the maximum coins obtained for subarray [left, right] in the DP table
            dp[left][right] = maxCoins;
        }
    }

    // Return the maximum coins for bursting all balloons between 1 and n
    return dp[1][n];
};

/**
 * Time Complexity: O(n^3)
 * - We have three nested loops: one for `left`, one for `right`, and one for choosing the last balloon to burst in the range.
 * 
 * Space Complexity: O(n^2)
 * - We use a DP table of size (n+2) x (n+2) to store the results of subproblems.
 */",Hard,"/**
 * @param {number[]} nums
 * @return {number}
 */
var maxCoins = function(nums) {
  // Handle edge cases
  if (!nums || nums.length === 0) {
    return 0;
  }

  // Add 1s to the beginning and end of the array to handle boundary conditions
  nums = [1, ...nums, 1];

  const n = nums.length;
  // dp[i][j] represents the maximum coins that can be obtained by bursting balloons from index i to j
  const dp = Array(n).fill(0).map(() => Array(n).fill(0));

  // Iterate through all possible subarrays
  for (let len = 2; len < n; len++) {
    for (let i = 0; i < n - len; i++) {
      const j = i + len;
      for (let k = i + 1; k < j; k++) {
        dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);
      }
    }
  }

  return dp[0][n - 1];
};","The solution uses dynamic programming to solve the problem.  It adds 1s to the beginning and end of the input array to simplify boundary condition handling. The dp array stores the maximum coins obtainable for subarrays. The code iterates through subarrays of increasing length, calculating the maximum coins for each subarray by considering all possible bursting orders. The final result is the maximum coins obtainable for the entire array.",22,23,5,5,"{""functionOrClassName"": ""maxCoins"", ""tests"": [""maxCoins([3,1,5,8])"", ""maxCoins([1,5])"", ""maxCoins([1])"", ""maxCoins([])"", ""maxCoins([7,9,8,0,7,1,3,5,5,2,3,3])"", ""maxCoins([8,2,6,8,9,8,1,4,1,5,3,0,7,7,0,4,2,2])"", ""maxCoins([9,76])"", ""maxCoins([1,3,2,4,5])"", ""maxCoins([1,10,1,1,10])"", ""maxCoins([5,4,3,2,1])""]}","let maxCoins=function(b){const d=b.length;b.push(1);b.unshift(1);const f=Array.from({length:d+2},()=>Array(d+2).fill(0));for(let a=d;1<=a;a--)for(let c=a;c<=d;c++){let g=-Infinity;for(let e=a;e<=c;e++)g=Math.max(g,b[a-1]*b[e]*b[c+1]+f[a][e-1]+f[e+1][c]);f[a][c]=g}return f[1][d]};
",0.8021670000000114,0.8987920000000003,0.8840839999999872,10,10,10
"var solveSudoku = function(board) {
    const solve = () => {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = '1'; num <= '9'; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) return true;
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    };
    
    const isValid = (board, row, col, num) => {
        for (let i = 0; i < 9; i++) {
            if (board[row][i] === num || board[i][col] === num) return false;
        }
        let startRow = Math.floor(row / 3) * 3;
        let startCol = Math.floor(col / 3) * 3;
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (board[i][j] === num) return false;
            }
        }
        return true;
    };
    
    solve();
};",Hard,"/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
    const solve = () => {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === '.') {
                    for (let k = 1; k <= 9; k++) {
                        if (isValid(i, j, k)) {
                            board[i][j] = k.toString();
                            if (solve()) return true;
                            board[i][j] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    };

    const isValid = (row, col, num) => {
        for (let i = 0; i < 9; i++) {
            if (board[row][i] === num.toString() || board[i][col] === num.toString()) return false;
        }
        const subgridRow = Math.floor(row / 3) * 3;
        const subgridCol = Math.floor(col / 3) * 3;
        for (let i = subgridRow; i < subgridRow + 3; i++) {
            for (let j = subgridCol; j < subgridCol + 3; j++) {
                if (board[i][j] === num.toString()) return false;
            }
        }
        return true;
    };

    solve();
};","The solution uses a backtracking algorithm. The `solve` function iterates through each cell. If a cell is empty, it tries numbers 1-9. The `isValid` function checks if placing a number in a cell is valid according to Sudoku rules. If a valid number is found, it recursively calls `solve`. If no valid number is found, it backtracks and tries a different number. If `solve` returns true, it means a solution is found. Otherwise, it means no solution exists.",33,33,4,5,-1,-1,-1,-1,-1,-1,-1,-1
